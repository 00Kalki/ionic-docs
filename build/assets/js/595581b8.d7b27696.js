(self.webpackChunkionic_docs=self.webpackChunkionic_docs||[]).push([[97376],{66966:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return l},toc:function(){return i},default:function(){return d}});var o=n(22122),r=n(19756),a=(n(67294),n(3905)),s={},l={unversionedId:"theming/css-shadow-parts",id:"theming/css-shadow-parts",isDocsHomePage:!1,title:"CSS Shadow Parts",description:"CSS Shadow Parts allow developers to style CSS properties on an element inside of a shadow tree. This is extremely useful in customizing Ionic Framework Shadow DOM components.",source:"@site/docs/theming/css-shadow-parts.md",sourceDirName:"theming",slug:"/theming/css-shadow-parts",permalink:"/docs/theming/css-shadow-parts",editUrl:"https://github.com/ionic-team/ionic-docs/edit/main/docs/theming/css-shadow-parts.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"CSS Variables",permalink:"/docs/theming/css-variables"},next:{title:"Colors",permalink:"/docs/theming/colors"}},i=[{value:"Why Shadow Parts?",id:"why-shadow-parts",children:[]},{value:"Shadow Parts Explained",id:"shadow-parts-explained",children:[{value:"Exposing a part",id:"exposing-a-part",children:[]},{value:"How ::part works",id:"how-part-works",children:[]}]},{value:"Ionic Framework Parts",id:"ionic-framework-parts",children:[]},{value:"Known Limitations",id:"known-limitations",children:[{value:"Browser Support",id:"browser-support",children:[]},{value:"Vendor Prefixed Pseudo-Elements",id:"vendor-prefixed-pseudo-elements",children:[]},{value:"Structural Pseudo-Classes",id:"structural-pseudo-classes",children:[]},{value:"Chaining Parts",id:"chaining-parts",children:[]}]}],p={toc:i};function d(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"CSS Shadow Parts allow developers to style CSS properties on an element inside of a shadow tree. This is extremely useful in customizing Ionic Framework ",(0,a.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM",target:"_blank",rel:"noopener noreferrer"},"Shadow DOM")," components."),(0,a.kt)("h2",{id:"why-shadow-parts"},"Why Shadow Parts?"),(0,a.kt)("p",null,"Ionic Framework is a distributed set of ",(0,a.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/Web_Components",target:"_blank",rel:"noopener noreferrer"},"Web Components"),". Web Components follow the ",(0,a.kt)("a",{href:"https://w3c.github.io/webcomponents/spec/shadow/",target:"_blank",rel:"noopener noreferrer"},"Shadow DOM specification")," in order to encapsulate styles and markup."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Ionic Framework components are ",(0,a.kt)("strong",{parentName:"p"},"not all")," Shadow DOM components. If the component is a Shadow DOM component, there will be a badge in the top right of its ",(0,a.kt)("a",{href:"/docs/components",target:"_blank",rel:"noopener noreferrer"},"component documentation"),". An example of a Shadow DOM component is the ",(0,a.kt)("a",{href:"/docs/api/button",target:"_blank",rel:"noopener noreferrer"},"button component"),".")),(0,a.kt)("p",null,"Shadow DOM is useful for preventing styles from leaking out of components and unintentionally applying to other elements. For example, we assign a ",(0,a.kt)("inlineCode",{parentName:"p"},".button")," class to our ",(0,a.kt)("inlineCode",{parentName:"p"},"ion-button")," component. Without Shadow DOM encapsulation, if a user were to set the class ",(0,a.kt)("inlineCode",{parentName:"p"},".button")," on one of their own elements, it would inherit the Ionic Framework button styles. Since ",(0,a.kt)("inlineCode",{parentName:"p"},"ion-button")," is a Shadow component, this is not a problem."),(0,a.kt)("p",null,"However, due to this encapsulation, styles aren\u2019t able to bleed into inner elements of Shadow components either. This means that if a Shadow component renders elements inside of its shadow tree, the inner elements cannot be targeted directly with CSS. Using the ",(0,a.kt)("inlineCode",{parentName:"p"},"ion-select")," component as an example, it renders the following markup:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},"<ion-select>\n  #shadow-root\n    <div class=\u201dselect-text select-placeholder\u201d></div>\n    <div class=\u201dselect-icon\u201d></div>\n</ion-select>\n")),(0,a.kt)("p",null,"The placeholder text and icon elements are inside of the ",(0,a.kt)("inlineCode",{parentName:"p"},"#shadow-root"),", which means the following CSS will ",(0,a.kt)("strong",{parentName:"p"},"NOT")," work to style the placeholder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-css"},"/* Does NOT work */\nion-select .select-placeholder {\n  color: blue;\n}\n")),(0,a.kt)("p",null,"So how do we solve this? ",(0,a.kt)("a",{parentName:"p",href:"#shadow-parts-explained"},"CSS Shadow Parts"),"!"),(0,a.kt)("h2",{id:"shadow-parts-explained"},"Shadow Parts Explained"),(0,a.kt)("p",null,"Shadow parts allow developers to style inside a shadow tree, from outside of that shadow tree. In order to do so, the ",(0,a.kt)("a",{parentName:"p",href:"#exposing-a-part"},"part must be exposed")," and then it can be styled by using ",(0,a.kt)("a",{parentName:"p",href:"#how-part-works"},"::part"),"."),(0,a.kt)("h3",{id:"exposing-a-part"},"Exposing a part"),(0,a.kt)("p",null,"When creating a Shadow DOM component, a part can be added to an element inside of a shadow tree by assigning a ",(0,a.kt)("inlineCode",{parentName:"p"},"part")," attribute on the element. This is added to the component in Ionic Framework and requires no action from an end user."),(0,a.kt)("p",null,"Continuing to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"ion-select")," component as an example, the markup is updated to look like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},"<ion-select>\n  #shadow-root\n    <div part=\u201dplaceholder\u201d class=\u201dselect-text select-placeholder\u201d></div>\n    <div part=\u201dicon\u201d class=\u201dselect-icon\u201d></div>\n</ion-select>\n")),(0,a.kt)("p",null,"The above shows two parts: ",(0,a.kt)("inlineCode",{parentName:"p"},"placeholder")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"icon"),". See the ",(0,a.kt)("a",{href:"/docs/api/select#css-shadow-parts",target:"_blank",rel:"noopener noreferrer"},"select documentation")," for all of its parts."),(0,a.kt)("p",null,"With these parts exposed, the element can now be styled directly using ",(0,a.kt)("a",{parentName:"p",href:"#how-part-works"},"::part"),"."),(0,a.kt)("h3",{id:"how-part-works"},"How ::part works"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/::part",target:"_blank",rel:"noopener noreferrer"},(0,a.kt)("inlineCode",{parentName:"p"},"::part()"))," pseudo-element allows developers to select elements inside of a shadow tree that have been exposed via a part attribute."),(0,a.kt)("p",null,"Since we know that ",(0,a.kt)("inlineCode",{parentName:"p"},"ion-select")," exposes a ",(0,a.kt)("inlineCode",{parentName:"p"},"placeholder")," part for styling the text when there is no value selected, we can customize it in the following way:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-css"},"ion-select::part(placeholder) {\n  color: blue;\n  opacity: 1;\n}\n")),(0,a.kt)("p",null,"Styling using ",(0,a.kt)("inlineCode",{parentName:"p"},"::part")," allows any CSS property that is accepted by that element to be changed."),(0,a.kt)("p",null,"In addition to being able to target the part, ",(0,a.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements",target:"_blank",rel:"noopener noreferrer"},"pseudo-elements")," can be styled without them being explicitly exposed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-css"},"ion-select::part(placeholder)::first-letter {\n  font-size: 22px;\n  font-weight: 500;\n}\n")),(0,a.kt)("p",null,"Parts work with most ",(0,a.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes",target:"_blank",rel:"noopener noreferrer"},"psuedo-classes"),", as well:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-css"},"ion-item::part(native):hover {\n  color: green;\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"There are some known limitations with ",(0,a.kt)("a",{parentName:"p",href:"#vendor-prefixed-pseudo-elements"},"vendor prefixed pseudo-elements")," and ",(0,a.kt)("a",{parentName:"p",href:"#structural-pseudo-classes"},"structural pseudo-classes"),".")),(0,a.kt)("h2",{id:"ionic-framework-parts"},"Ionic Framework Parts"),(0,a.kt)("p",null,"All exposed parts for an Ionic Framework component can be found under the CSS Shadow Parts heading on its API page. To view all components and their API pages, see the ",(0,a.kt)("a",{href:"/docs/components",target:"_blank",rel:"noopener noreferrer"},"Component documentation"),"."),(0,a.kt)("p",null,"In order to have parts a component must meet the following criteria:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It is a ",(0,a.kt)("a",{href:"/docs/reference/glossary#shadow",target:"_blank",rel:"noopener noreferrer"},"Shadow DOM")," component. If it is a ",(0,a.kt)("a",{href:"/docs/reference/glossary#scoped",target:"_blank",rel:"noopener noreferrer"},"Scoped")," or Light DOM component, the child elements can be targeted directly. If a component is Scoped or Shadow, it will be listed by its name on its ",(0,a.kt)("a",{href:"/docs/components",target:"_blank",rel:"noopener noreferrer"},"component documentation page"),"."),(0,a.kt)("li",{parentName:"ul"},"It contains children elements. For example, ",(0,a.kt)("inlineCode",{parentName:"li"},"ion-card-header")," is a Shadow component, but all styles are applied to the host element. Since it has no child elements, there\u2019s no need for parts."),(0,a.kt)("li",{parentName:"ul"},"The children elements are not structural. In certain components, including ",(0,a.kt)("inlineCode",{parentName:"li"},"ion-title"),", the child element is a structural element used to position the inner elements. We do not recommend customizing structural elements as this can have unexpected results.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"We welcome recommendations for additional parts. Please create a ",(0,a.kt)("a",{href:"https://github.com/ionic-team/ionic-framework/issues/new?assignees=&labels=&template=feature_request.md&title=feat%3A+",target:"_blank",rel:"noopener noreferrer"},"new GitHub issue")," with as much information as possible when requesting a part.")),(0,a.kt)("h2",{id:"known-limitations"},"Known Limitations"),(0,a.kt)("h3",{id:"browser-support"},"Browser Support"),(0,a.kt)("p",null,"CSS Shadow Parts are supported in the recent versions of all of the major browsers. However, some of the older versions do not support shadow parts. Verify the ",(0,a.kt)("a",{href:"https://caniuse.com/#feat=mdn-css_selectors_part",target:"_blank",rel:"noopener noreferrer"},"browser support")," meets the requirements before implementing parts in an app. If browser support for older versions is required, we recommend continuing to use ",(0,a.kt)("a",{href:"/docs/theming/css-variables",target:"_blank",rel:"noopener noreferrer"},"CSS Variables")," for styling."),(0,a.kt)("h3",{id:"vendor-prefixed-pseudo-elements"},"Vendor Prefixed Pseudo-Elements"),(0,a.kt)("a",{href:"https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix",target:"_blank",rel:"noopener noreferrer"},"Vendor prefixed")," pseudo-elements are not supported at this time. An example of this would be any of the `::-webkit-scrollbar` pseudo-elements:",(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-css"},"/* Does NOT work */\nmy-component::part(scroll)::-webkit-scrollbar {\n  background: green;\n}\n")),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{href:"https://github.com/w3c/csswg-drafts/issues/4530",target:"_blank",rel:"noopener noreferrer"},"this issue on GitHub")," for more information."),(0,a.kt)("h3",{id:"structural-pseudo-classes"},"Structural Pseudo-Classes"),(0,a.kt)("p",null,"Most pseudo-classes are supported with parts, however, ",(0,a.kt)("a",{href:"https://www.w3.org/TR/selectors-4/#structural-pseudos",target:"_blank",rel:"noopener noreferrer"},"structural pseudo-classes")," are not. An example of structural pseudo-classes that do not work is below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-css"},"/* Does NOT work */\nmy-component::part(container):first-child {\n  background: green;\n}\n\n/* Does NOT work */\nmy-component::part(container):last-child {\n  background: green;\n}\n")),(0,a.kt)("h3",{id:"chaining-parts"},"Chaining Parts"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"::part()")," pseudo-element can not match additional ",(0,a.kt)("inlineCode",{parentName:"p"},"::part()"),"s."),(0,a.kt)("p",null,"For example, ",(0,a.kt)("inlineCode",{parentName:"p"},"my-component::part(button)::part(label)")," does not match anything. This is because doing so would expose more structural information than is intended."),(0,a.kt)("p",null,"If the ",(0,a.kt)("inlineCode",{parentName:"p"},"<my-component>"),"\u2019s internal button uses something like ",(0,a.kt)("inlineCode",{parentName:"p"},'part="label => button-label"')," to forward the button\u2019s internal parts up into the panel\u2019s own part element map, then a selector like ",(0,a.kt)("inlineCode",{parentName:"p"},"my-component::part(button-label)")," would select just the one button\u2019s label, ignoring any other labels."))}d.isMDXComponent=!0}}]);