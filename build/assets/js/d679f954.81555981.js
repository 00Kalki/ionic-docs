(self.webpackChunkionic_docs=self.webpackChunkionic_docs||[]).push([[4995],{59295:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},metadata:function(){return r},toc:function(){return s},default:function(){return c}});var a=n(22122),i=n(19756),o=(n(67294),n(3905)),l={sidebar_label:"Lifecycle"},r={unversionedId:"angular/lifecycle",id:"angular/lifecycle",isDocsHomePage:!1,title:"Ionic Page Life Cycle",description:"This guide covers how the page life cycle works in an app built with Ionic and Angular.",source:"@site/docs/angular/lifecycle.md",sourceDirName:"angular",slug:"/angular/lifecycle",permalink:"/docs/angular/lifecycle",editUrl:"https://github.com/ionic-team/ionic-docs/edit/main/docs/angular/lifecycle.md",version:"current",sidebar_label:"Lifecycle",frontMatter:{sidebar_label:"Lifecycle"},sidebar:"docs",previous:{title:"Rapid App Development with Live Reload",permalink:"/docs/angular/your-first-app/live-reload"},next:{title:"Angular Navigation",permalink:"/docs/angular/navigation"}},s=[{value:"Angular Life Cycle Events",id:"angular-life-cycle-events",children:[]},{value:"Ionic Page Events",id:"ionic-page-events",children:[]},{value:"How Ionic Handles the Life of a Page",id:"how-ionic-handles-the-life-of-a-page",children:[]},{value:"Route Guards",id:"route-guards",children:[]},{value:"Guidance for Each Life Cycle Method",id:"guidance-for-each-life-cycle-method",children:[]}],d={toc:s};function c(e){var t=e.components,l=(0,i.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This guide covers how the page life cycle works in an app built with Ionic and Angular."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Ionic life cycle events demo",src:n(31737).Z})),(0,o.kt)("h2",{id:"angular-life-cycle-events"},"Angular Life Cycle Events"),(0,o.kt)("p",null,"Ionic embraces the life cycle events provided by Angular. The two Angular events you will find using the most are:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Event Name"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"ngOnInit")),(0,o.kt)("td",{parentName:"tr",align:null},"Fired once during component initialization. This event can be used to initialize local members and make calls into services that only need to be done once.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"ngOnDestroy")),(0,o.kt)("td",{parentName:"tr",align:null},"Fired right before Angular destroys the view. Useful for cleanup like unsubscribing from observables.")))),(0,o.kt)("p",null,"For more info on the Angular Component Life Cycle events, visit their ",(0,o.kt)("a",{parentName:"p",href:"https://angular.io/guide/lifecycle-hooks"},"component lifecycle docs"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Components that use ",(0,o.kt)("inlineCode",{parentName:"p"},"ion-nav")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"ion-router-outlet")," should not use the ",(0,o.kt)("inlineCode",{parentName:"p"},"OnPush")," change detection strategy. Doing so will prevent lifecycle hooks such as ",(0,o.kt)("inlineCode",{parentName:"p"},"ngOnInit")," from firing. Additionally, asynchronous state changes may not render properly.")),(0,o.kt)("h2",{id:"ionic-page-events"},"Ionic Page Events"),(0,o.kt)("p",null,"In addition to the Angular life cycle events, Ionic Angular provides a few additional events that you can use:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Event Name"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"ionViewWillEnter")),(0,o.kt)("td",{parentName:"tr",align:null},"Fired when the component routing to is about to animate into view.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"ionViewDidEnter")),(0,o.kt)("td",{parentName:"tr",align:null},"Fired when the component routing to has finished animating.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"ionViewWillLeave")),(0,o.kt)("td",{parentName:"tr",align:null},"Fired when the component routing from is about to animate.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"ionViewDidLeave")),(0,o.kt)("td",{parentName:"tr",align:null},"Fired when the component routing to has finished animating.")))),(0,o.kt)("p",null,"The difference between ",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewWillEnter")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewDidEnter")," is when they fire. The former fires right after ",(0,o.kt)("inlineCode",{parentName:"p"},"ngOnInit")," but before the page transition begins, and the latter directly after the transition ends. "),(0,o.kt)("p",null,"For ",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewWillLeave")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewDidLeave"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewWillLeave")," gets called directly before the transition away from the current page begins, and ",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewDidLeave")," does not get called until after the new page gets successfully transitioned into (after the new pages ",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewDidEnter")," fires)."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Ionic life cycle events demo",src:n(50078).Z})),(0,o.kt)("h2",{id:"how-ionic-handles-the-life-of-a-page"},"How Ionic Handles the Life of a Page"),(0,o.kt)("p",null,"Ionic has its router outlet, called ",(0,o.kt)("inlineCode",{parentName:"p"},"<ion-router-outlet />"),". This outlet extends Angular's ",(0,o.kt)("inlineCode",{parentName:"p"},"<router-outlet />")," with some additional functionality to enable better experiences for mobile devices."),(0,o.kt)("p",null,"When an app is wrapped in ",(0,o.kt)("inlineCode",{parentName:"p"},"<ion-router-outlet />"),", Ionic treats navigation a bit differently. When you navigate to a new page, Ionic will keep the old page in the existing DOM, but hide it from your view and transition the new page. The reason we do this is two-fold: "),(0,o.kt)("p",null,"1) We can maintain the state of the old page (data on the screen, scroll position, etc..)",(0,o.kt)("br",{parentName:"p"}),"\n","2) We can provide a smoother transition back to the page since it is already there and doesn't need to be recreated."),(0,o.kt)("p",null,'Pages are only removed from the DOM when they are "popped", for instance, by pressing the back button in the UI or the browsers back button.'),(0,o.kt)("p",null,"Because of this special handling, the ",(0,o.kt)("inlineCode",{parentName:"p"},"ngOnInit")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ngOnDestroy")," methods might not fire when you would usually think they should."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ngOnInit")," will only fire each time the page is freshly created, but not when navigated back to the page. For instance, navigating between each page in a tabs interface will only call each page's ",(0,o.kt)("inlineCode",{parentName:"p"},"ngOnInit")," method once, but not on subsequent visits. ",(0,o.kt)("inlineCode",{parentName:"p"},"ngOnDestroy"),' will only fire when a page "popped".'),(0,o.kt)("h2",{id:"route-guards"},"Route Guards"),(0,o.kt)("p",null,"In Ionic 3, there were a couple of additional life cycle methods that were useful to control when a page could be entered (",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewCanEnter"),") and left (",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewCanLeave"),"). These could be used to protect pages from unauthorized users and to keep a user on a page when you don't want them to leave (like during a form fill)."),(0,o.kt)("p",null,"These methods were removed in Ionic 4 in favor of using Angular's Route Guards. "),(0,o.kt)("p",null,"A route guard helps determine if a particular action can be taken against a route. They are classes that implement a certain interface. The ",(0,o.kt)("inlineCode",{parentName:"p"},"CanActivate")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"CanDeactivate")," interfaces can be used to implement the same type of logic that the removed events ",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewCanEnter")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ionViewCanLeave")," did."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Injectable()\nexport class AuthGuard implements CanActivate {\n  constructor(private authService: AuthService) {}\n\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n    return this.authService.isAuthenticated();\n  }\n}\n")),(0,o.kt)("p",null,"To use this guard, add it to the appropriate param in the route definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"{ path: 'settings', canActivate: [AuthGuard], loadChildren: '...',  }\n")),(0,o.kt)("p",null,"For more info on how to use route guards, go to Angular's ",(0,o.kt)("a",{parentName:"p",href:"https://angular.io/guide/router"},"router documentation"),"."),(0,o.kt)("h2",{id:"guidance-for-each-life-cycle-method"},"Guidance for Each Life Cycle Method"),(0,o.kt)("p",null,"Below are some tips on uses cases for each of the life cycle events."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngOnInit")," - Initialize your component and load data from services that don't need refreshing on each subsequent visit."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ionViewWillEnter")," - Since ",(0,o.kt)("inlineCode",{parentName:"li"},"ionViewWillEnter")," is called every time the view is navigated to (regardless if initialized or not), it's a good method to load data from services. However, if your data comes back during the animation, it can start lots of DOM manipulation, which can cause some janky animations."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ionViewDidEnter")," - If you see performance problems from using ",(0,o.kt)("inlineCode",{parentName:"li"},"ionViewWillEnter"),"  when loading data, you can do your data calls in ",(0,o.kt)("inlineCode",{parentName:"li"},"ionViewDidEnter")," instead. This event won't fire until after the page is visible by the user, however, so you might want to use either a loading indicator or a skeleton screen, so content doesn't flash in un-naturally after the transition is complete."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ionViewWillLeave")," - Can be used for cleanup, like unsubscribing from observables. Since ",(0,o.kt)("inlineCode",{parentName:"li"},"ngOnDestroy")," might not fire when you navigate from the current page, put your cleanup code here if you don't want it active while the screen is not in view."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ionViewDidLeave")," - When this event fires, you know the new page has fully transitioned in, so any logic you might not normally do when the view is visible can go here."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ngOnDestroy")," - Cleanup logic for your pages that you don't want to clean up in ",(0,o.kt)("inlineCode",{parentName:"li"},"ionViewWillLeave"),".")))}c.isMDXComponent=!0},50078:function(e,t,n){"use strict";t.Z=n.p+"assets/images/ioniclifecycle-91a560248eb41e8fea3b6eb6f9bbec8a.gif"},31737:function(e,t,n){"use strict";t.Z=n.p+"assets/images/ioniclifecycle-bb082b342a467327ecba827db5943e8f.png"}}]);