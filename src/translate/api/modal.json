{
  "filePath": "./src/components/modal/modal.tsx",
  "encapsulation": "shadow",
  "tag": "ion-modal",
  "readme": "# ion-modal\n\nA Modal is a dialog that appears on top of the app's content, and must be dismissed by the app before interaction can resume. It is useful as a select component when there are a lot of options to choose from, or when filtering items in a list, as well as many other use cases.\n\n## Presenting\n\nThere are two ways to use `ion-modal`: inline or via the `modalController`. Each method comes with different considerations, so be sure to use the approach that best fits your use case.\n\n## Inline Modals\n\n`ion-modal` can be used by writing the component directly in your template. This reduces the number of handlers you need to wire up in order to present the modal. See [Usage](#usage) for an example of how to write a modal inline. \n\nWhen using `ion-modal` with Angular, React, or Vue, the component you pass in will be destroyed when the modal is dismissed. As this functionality is provided by the JavaScript framework, using `ion-modal` without a JavaScript framework will not destroy the component you passed in. If this is a needed functionality, we recommend using the `modalController` instead.\n\n### Angular \n\nSince the component you passed in needs to be created when the modal is presented and destroyed when the modal is dismissed, we are unable to project the content using `<ng-content>` internally. Instead, we use `<ng-container>` which expects an `<ng-template>` to be passed in. As a result, when passing in your component you will need to wrap it in an `<ng-template>`:\n\n```html\n<ion-modal [isOpen]=\"isModalOpen\">\n  <ng-template>\n    <app-modal-content></app-modal-content>\n  </ng-template>\n</ion-modal>\n```\n\n### When to use\n\nUsing a modal inline is useful when you do not want to explicitly wire up click events to open the modal. For example, you can use the `is-open` property to easily present or dismiss a modal based on some state in your application.\n\nIf you need fine grained control over when the modal is presented and dismissed, we recommend you use the `modalController`. \n\n## Controller Modals\n\n`ion-modal` can also be presented programmatically by using the `modalController` imported from Ionic Framework. This allows you to have complete control over when a modal is presented above and beyond the customization that inline modals give you. See [Usage](#usage) for an example of how to use the `modalController`.\n\n### When to use\n\nWe typically recommend that you write your modals inline as it streamlines the amount of code in your application. You should only use the `modalController` for complex use cases where writing a modal inline is impractical.\n\n## Card Modal\n\nDevelopers can create a card modal effect where the modal appears as a card stacked on top of your app's main content. To create a card modal, developers need to set the `presentingElement` property and the `swipeToClose` properties on `ion-modal`.\n\nThe `presentingElement` property accepts a reference to the element that should display under your modal. This is typically a reference to `ion-router-outlet`.\n\nThe `swipeToClose` property can be used to control whether or not the card modal can be swiped to close.\n\nSee [Usage](#usage) for examples on how to use the sheet modal.\n\n## Sheet Modal\n\nDevelopers can create a sheet modal effect similar to the drawer components available in maps applications. To create a sheet modal, developers need to set the `breakpoints` and `initialBreakpoint` properties on `ion-modal`.\n\nThe `breakpoints` property accepts an array which states each breakpoint that the sheet can snap to when swiped. A `breakpoints` property of `[0, 0.5, 1]` would indicate that the sheet can be swiped to show 0% of the modal, 50% of the modal, and 100% of the modal. When the modal is swiped to 0%, the modal will be automatically dismissed.\n\nThe `initialBreakpoint` property is required so that the sheet modal knows which breakpoint to start at when presenting. The `initalBreakpoint` value must also exist in the `breakpoints` array. Given a `breakpoints` value of `[0, 0.5, 1]`, an `initialBreakpoint` value of `0.5` would be valid as `0.5` is in the `breakpoints` array. An `initialBreakpoint` value of `0.25` would not be valid as `0.25` does not exist in the `breakpoints` array.\n\nThe `backdropBreakpoint` property can be used to customize the point at which the `ion-backdrop` will begin to fade in. This is useful when creating interfaces that have content underneath the sheet that should remain interactive. A common use case is a sheet modal that overlays a map where the map is interactive until the sheet is fully expanded.\n\nSee [Usage](#usage) for examples on how to use the sheet modal.\n\n> Note: The `swipeToClose` property has no effect when using a sheet modal as sheet modals must be swipeable in order to be usable.\n\n## Interfaces\n\nBelow you will find all of the options available to you when using the `modalController`. These options should be supplied when calling `modalController.create()`.\n\n```typescript\ninterface ModalOptions {\n  component: any;\n  componentProps?: { [key: string]: any };\n  presentingElement?: HTMLElement;\n  showBackdrop?: boolean;\n  backdropDismiss?: boolean;\n  cssClass?: string | string[];\n  animated?: boolean;\n  swipeToClose?: boolean;\n\n  mode?: 'ios' | 'md';\n  keyboardClose?: boolean;\n  id?: string;\n\n  enterAnimation?: AnimationBuilder;\n  leaveAnimation?: AnimationBuilder;\n}\n```\n\n## Dismissing\n\nThe modal can be dismissed after creation by calling the `dismiss()` method on the modal controller. The `onDidDismiss` function can be called to perform an action after the modal is dismissed.\n\n## Styling\n\nModals are presented at the root of your application so they overlay your entire app. This behavior applies to both inline modals and modals presented from a controller. As a result, custom modal styles can not be scoped to a particular component as they will not apply to the modal. Instead, styles must be applied globally. For most developers, placing the custom styles in `global.css` is sufficient.\n\n> If you are building an Ionic Angular app, the styles need to be added to a global stylesheet file. Read [Style Placement](#style-placement) in the Angular section below for more information.\n\n> `ion-modal` works under the assumption that stacked modals are the same size. As a result, each subsequent modal will have no box shadow and a backdrop opacity of `0`. This is to avoid the effect of shadows and backdrops getting darker with each added modal. This can be changed by setting the `--box-shadow` and `--backdrop-opacity` CSS variables:\n``` \nion-modal.stack-modal {\n  --box-shadow: 0 28px 48px rgba(0, 0, 0, 0.4);\n  --backdrop-opacity: var(--ion-backdrop-opacity, 0.32);\n}\n```\n\n## Interfaces\n\n### ModalOptions\n\n```typescript\ninterface ModalOptions<T extends ComponentRef = ComponentRef> {\n  component: T;\n  componentProps?: ComponentProps<T>;\n  presentingElement?: HTMLElement;\n  showBackdrop?: boolean;\n  backdropDismiss?: boolean;\n  cssClass?: string | string[];\n  animated?: boolean;\n  swipeToClose?: boolean;\n\n  mode?: Mode;\n  keyboardClose?: boolean;\n  id?: string;\n  htmlAttributes?: ModalAttributes;\n\n  enterAnimation?: AnimationBuilder;\n  leaveAnimation?: AnimationBuilder;\n\n  breakpoints?: number[];\n  initialBreakpoint?: number;\n  backdropBreakpoint?: number;\n  handle?: boolean;\n}\n```\n\n### ModalAttributes\n\n```typescript\ninterface ModalAttributes extends JSXBase.HTMLAttributes<HTMLElement> {}\n```\n\n",
  "docs": "A Modal is a dialog that appears on top of the app's content, and must be dismissed by the app before interaction can resume. It is useful as a select component when there are a lot of options to choose from, or when filtering items in a list, as well as many other use cases.",
  "docsTags": [
    {
      "name": "virtualProp",
      "text": "{\"ios\" | \"md\"} mode - The mode determines which platform styles to use."
    },
    {
      "name": "slot",
      "text": "= Content is placed inside of the `.modal-content` element."
    },
    {
      "name": "part",
      "text": "backdrop - The `ion-backdrop` element."
    },
    {
      "name": "part",
      "text": "content - The wrapper element for the default slot."
    },
    {
      "name": "part",
      "text": "handle - The handle that is displayed at the top of the sheet modal when `handle=\"true\"`."
    }
  ],
  "usage": {
    "angular": "### Inline Modal\n\n```html\n<!-- Default -->\n<ion-modal [isOpen]=\"true\">\n  <ng-template>\n    <ion-content>Modal Content</ion-content>\n  </ng-template>\n</ion-modal>\n\n<!-- Use a trigger -->\n<ion-button id=\"trigger-button\">Click to open modal</ion-button>\n<ion-modal trigger=\"trigger-button\">\n  <ng-template>\n    <ion-content>Modal Content</ion-content>\n  </ng-template>\n</ion-modal>\n\n<!-- Sheet Modal -->\n<ion-modal\n  [isOpen]=\"true\"\n  [breakpoints]=\"[0.1, 0.5, 1]\"\n  [initialBreakpoint]=\"0.5\"\n>\n  <ng-template>\n    <ion-content>Modal Content</ion-content>\n  </ng-template>\n</ion-modal>\n\n<!-- Card Modal -->\n<ion-modal\n  [isOpen]=\"true\"\n  [swipeToClose]=\"true\"\n  [presentingElement]=\"routerOutlet.nativeEl\"\n>\n  <ng-template>\n    <ion-content>Modal Content</ion-content>\n  </ng-template>\n</ion-modal>\n\n<!-- Passing Props -->\n<ion-modal [isOpen]=\"true\">\n  <ng-template>\n    <app-angular-component title=\"Ionic\"></app-angular-component>\n  </ng-template>\n</ion-modal>\n```\n\n```typescript\nimport { Component } from '@angular/core';\nimport { IonRouterOutlet } from '@ionic/angular';\n\n@Component({\n  selector: 'modal-example',\n  templateUrl: 'modal-example.html',\n  styleUrls: ['./modal-example.css']\n})\nexport class ModalExample {\n  constructor(public routerOutlet: IonRouterOutlet) {}\n}\n```\n\n### Modal Controller\n\n```typescript\nimport { Component } from '@angular/core';\nimport { ModalController } from '@ionic/angular';\nimport { ModalPage } from '../modal/modal.page';\n\n@Component({\n  selector: 'modal-example',\n  templateUrl: 'modal-example.html',\n  styleUrls: ['./modal-example.css']\n})\nexport class ModalExample {\n  constructor(public modalController: ModalController) {\n\n  }\n\n  async presentModal() {\n    const modal = await this.modalController.create({\n      component: ModalPage,\n      cssClass: 'my-custom-class'\n    });\n    return await modal.present();\n  }\n}\n```\n\n```typescript\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'modal-page',\n})\nexport class ModalPage {\n\n  constructor() {}\n\n}\n```\n\n> If you need a wrapper element inside of your modal component, we recommend using a `<div class=\"ion-page\">` so that the component dimensions are still computed properly.\n\n#### Passing Data\n\nDuring creation of a modal, data can be passed in through the `componentProps`.\nThe previous example can be written to include data:\n\n```typescript\nasync presentModal() {\n  const modal = await this.modalController.create({\n    component: ModalPage,\n    cssClass: 'my-custom-class',\n    componentProps: {\n      'firstName': 'Douglas',\n      'lastName': 'Adams',\n      'middleInitial': 'N'\n    }\n  });\n  return await modal.present();\n}\n```\n\nTo get the data passed into the `componentProps`, set it as an `@Input`:\n\n```typescript\nexport class ModalPage {\n\n  // Data passed in by componentProps\n  @Input() firstName: string;\n  @Input() lastName: string;\n  @Input() middleInitial: string;\n\n}\n```\n\n#### Dismissing a Modal\n\nA modal can be dismissed by calling the dismiss method on the modal controller and optionally passing any data from the modal.\n\n```javascript\nexport class ModalPage {\n  ...\n\n  dismiss() {\n    // using the injected ModalController this page\n    // can \"dismiss\" itself and optionally pass back data\n    this.modalController.dismiss({\n      'dismissed': true\n    });\n  }\n}\n```\n\nAfter being dismissed, the data can be read in through the `onWillDismiss` or `onDidDismiss` attached to the modal after creation:\n\n```javascript\nconst { data } = await modal.onWillDismiss();\nconsole.log(data);\n```\n\n\n#### Lazy Loading\n\nWhen lazy loading a modal, it's important to note that the modal will not be loaded when it is opened, but rather when the module that imports the modal's module is loaded.\n\nFor example, say there exists a `CalendarComponent` and an `EventModal`. The modal is presented by clicking a button in the `CalendarComponent`. In Angular, the `EventModalModule` would need to be included in the `CalendarComponentModule` since the modal is created in the `CalendarComponent`:\n\n```typescript\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule } from '@ionic/angular';\n\nimport { CalendarComponent } from './calendar.component';\nimport { EventModalModule } from '../modals/event/event.module';\n\n@NgModule({\n  declarations: [\n    CalendarComponent\n  ],\n  imports: [\n    IonicModule,\n    CommonModule,\n    EventModalModule\n  ],\n  exports: [\n    CalendarComponent\n  ]\n})\n\nexport class CalendarComponentModule {}\n```\n\n#### Card Modals\n\nModals in iOS mode have the ability to be presented in a card-style and swiped to close. The card-style presentation and swipe to close gesture are not mutually exclusive, meaning you can pick and choose which features you want to use. For example, you can have a card-style modal that cannot be swiped or a full sized modal that can be swiped.\n\n> Card style modals when running on iPhone-sized devices do not have backdrops. As a result, the `--backdrop-opacity` variable will not have any effect.\n\nIf you are creating an application that uses `ion-tabs`, it is recommended that you get the parent `ion-router-outlet` using `this.routerOutlet.parentOutlet.nativeEl`, otherwise the tabbar will not scale down when the modal opens.\n\n```javascript\nimport { IonRouterOutlet } from '@ionic/angular';\n\nconstructor(private routerOutlet: IonRouterOutlet) {}\n\nasync presentModal() {\n  const modal = await this.modalController.create({\n    component: ModalPage,\n    cssClass: 'my-custom-class',\n    swipeToClose: true,\n    presentingElement: this.routerOutlet.nativeEl\n  });\n  return await modal.present();\n}\n```\n\nIn most scenarios, using the `ion-router-outlet` element as the `presentingElement` is fine. In cases where you are presenting a card-style modal from within another modal, you should pass in the top-most `ion-modal` element as the `presentingElement`.\n\n```javascript\nimport { ModalController } from '@ionic/angular';\n\nconstructor(private modalController: ModalController) {}\n\nasync presentModal() {\n  const modal = await this.modalController.create({\n    component: ModalPage,\n    cssClass: 'my-custom-class',\n    swipeToClose: true,\n    presentingElement: await this.modalController.getTop() // Get the top-most ion-modal\n  });\n  return await modal.present();\n}\n```\n\n#### Sheet Modals\n\n```javascript\nimport { IonRouterOutlet } from '@ionic/angular';\n\nconstructor(private routerOutlet: IonRouterOutlet) {}\n\nasync presentModal() {\n  const modal = await this.modalController.create({\n    component: ModalPage,\n    initialBreakpoint: 0.5,\n    breakpoints: [0, 0.5, 1]\n  });\n  return await modal.present();\n}\n```\n\n### Style Placement\n\nIn Angular, the CSS of a specific page is scoped only to elements of that page. Even though the Modal can be presented from within a page, the `ion-modal` element is appended outside of the current page. This means that any custom styles need to go in a global stylesheet file. In an Ionic Angular starter this can be the `src/global.scss` file or you can register a new global style file by [adding to the `styles` build option in `angular.json`](https://angular.io/guide/workspace-config#style-script-config).\n",
    "javascript": "### Inline Modal\n\n```html\n<!-- Default -->\n<ion-modal is-open=\"true\">\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Use a trigger -->\n<ion-button id=\"trigger-button\">Click to open modal</ion-button>\n<ion-modal trigger=\"trigger-button\">\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Sheet Modal -->\n<ion-modal is-open=\"true\" id=\"sheet-modal\">\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Card Modal -->\n<ion-modal is-open=\"true\" id=\"card-modal\">\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<script>\n  const sheetModal = document.querySelector('#sheet-modal');\n  const cardModal = document.querySelector('#sheet-modal');\n\n  sheetModal.breakpoints = [0.1, 0.5, 1];\n  sheetModal.initialBreakpoint = 0.5;\n  \n  cardModal.swipeToClose = true;\n  cardModal.presentingElement = document.querySelector('ion-app');\n</script>\n```\n\n### Using JavaScript\n\n```javascript\ncustomElements.define('modal-page', class extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = `\n<ion-header>\n  <ion-toolbar>\n    <ion-title>Modal Header</ion-title>\n    <ion-buttons slot=\"primary\">\n      <ion-button onClick=\"dismissModal()\">\n        <ion-icon slot=\"icon-only\" name=\"close\"></ion-icon>\n      </ion-button>\n    </ion-buttons>\n  </ion-toolbar>\n</ion-header>\n<ion-content class=\"ion-padding\">\n  Modal Content\n</ion-content>`;\n  }\n});\n\nfunction presentModal() {\n  // create the modal with the `modal-page` component\n  const modalElement = document.createElement('ion-modal');\n  modalElement.component = 'modal-page';\n  modalElement.cssClass = 'my-custom-class';\n\n  // present the modal\n  document.body.appendChild(modalElement);\n  return modalElement.present();\n}\n```\n\n> If you need a wrapper element inside of your modal component, we recommend using a `<div class=\"ion-page\">` so that the component dimensions are still computed properly.\n\n### Passing Data\n\nDuring creation of a modal, data can be passed in through the `componentProps`. The previous example can be written to include data:\n\n```javascript\nconst modalElement = document.createElement('ion-modal');\nmodalElement.component = 'modal-page';\nmodalElement.cssClass = 'my-custom-class';\nmodalElement.componentProps = {\n  'firstName': 'Douglas',\n  'lastName': 'Adams',\n  'middleInitial': 'N'\n};\n```\n\nTo get the data passed into the `componentProps`, query for the modal in the `modal-page`:\n\n```js\ncustomElements.define('modal-page', class extends HTMLElement {\n  connectedCallback() {\n    const modalElement = document.querySelector('ion-modal');\n    console.log(modalElement.componentProps.firstName);\n\n    ...\n  }\n}\n```\n\n\n### Dismissing a Modal\n\nA modal can be dismissed by calling the dismiss method and optionally passing any data from the modal.\n\n```javascript\nasync function dismissModal() {\n  await modal.dismiss({\n    'dismissed': true\n  });\n}\n```\n\nAfter being dismissed, the data can be read in through the `onWillDismiss` or `onDidDismiss` attached to the modal after creation:\n\n```javascript\nconst { data } = await modalElement.onWillDismiss();\nconsole.log(data);\n```\n\n\n### Card Modals\n\nModals in iOS mode have the ability to be presented in a card-style and swiped to close. The card-style presentation and swipe to close gesture are not mutually exclusive, meaning you can pick and choose which features you want to use. For example, you can have a card-style modal that cannot be swiped or a full sized modal that can be swiped.\n\n> Card style modals when running on iPhone-sized devices do not have backdrops. As a result, the `--backdrop-opacity` variable will not have any effect.\n\n```javascript\nconst modalElement = document.createElement('ion-modal');\nmodalElement.component = 'modal-page';\nmodalElement.cssClass = 'my-custom-class';\nmodalElement.swipeToClose = true;\nmodalElement.presentingElement = document.querySelector('ion-nav');\n```\n\nIn most scenarios, using the `ion-nav` element as the `presentingElement` is fine. In cases where you are presenting a card-style modal from within a modal, you should pass in the top-most `ion-modal` element as the `presentingElement`.\n\n```javascript\nconst modalElement = document.createElement('ion-modal');\nmodalElement.component = 'modal-page';\nmodalElement.cssClass = 'my-custom-class';\nmodalElement.swipeToClose = true;\nmodalElement.presentingElement = await modalController.getTop(); // Get the top-most ion-modal\n```\n\n### Sheet Modals\n\n```javascript\nconst modalElement = document.createElement('ion-modal');\nmodalElement.component = 'modal-page';\nmodalElement.initialBreakpoint = 0.5;\nmodalElement.breakpoints = [0, 0.5, 1];\n```",
    "react": "### Inline Modal\n\n```tsx\nimport { React, useRef } from 'react';\nconst App: React.FC = () => {\n  const routerRef = useRef<HTMLIonRouterOutletElement | null>(null);\n  \n  return (\n    <IonApp>\n      <IonReactRouter>\n        <IonRouterOutlet ref={routerRef}>\n          <Route path=\"/home\" render={() => <Home router={routerRef.current} />}  exact={true} />\n        </IonRouterOutlet>\n      </IonReactRouter>\n    </IonApp>\n  )\n};\n\n...\n\ninterface Props {\n  router: HTMLIonRouterOutletElement | null;\n}\n\nimport React from 'react';\nimport AppReactComponent from './AppReactComponent';\nimport { IonModal, IonContent, IonButton } from '@ionic/react';\nexport const ModalExample: React.FC<Props> = ({ router }) => {\n  return (\n    <>\n      {/* Default */}\n      <IonModal isOpen={true}>\n        <IonContent>Modal Content</IonContent>\n      </IonModal>\n      \n      {/* Use a trigger */}\n      <IonButton id=\"trigger-button\">Click to open modal</IonButton>\n      <IonModal trigger=\"trigger-button\">\n        <IonContent>Modal Content</IonContent>\n      </IonModal>\n      \n      {/* Sheet Modal */}\n      <IonModal\n        isOpen={true}\n        breakpoints={[0.1, 0.5, 1]}\n        initialBreakpoint={0.5}\n      >\n        <IonContent>Modal Content</IonContent>\n      </IonModal>\n      \n      {/* Card Modal */}\n      <IonModal\n        isOpen={true}\n        swipeToClose={true}\n        presentingElement={router || undefined}\n      >\n        <IonContent>Modal Content</IonContent>\n      </IonModal>\n      \n      {/* Passing Props */}\n      <IonModal isOpen={true}>\n        <AppReactComponent title=\"Ionic\"></AppReactComponent>\n      </IonModal>\n    </>\n  );\n};\n```\n\n\n### useIonModal Hook\n\n> `useIonModal` requires being a descendant of `<IonApp>`. If you need to use a modal outside of an `<IonApp>`, consider using the component method instead.\n\n\n```tsx\n/* Using with useIonModal Hook */ \n\nimport React, { useState } from 'react';\nimport { IonButton, IonContent, IonPage, useIonModal } from '@ionic/react';\n\nconst Body: React.FC<{\n  count: number;\n  onDismiss: () => void;\n  onIncrement: () => void;\n}> = ({ count, onDismiss, onIncrement }) => (\n  <div>\n    count: {count}\n    <IonButton expand=\"block\" onClick={() => onIncrement()}>\n      Increment Count\n    </IonButton>\n    <IonButton expand=\"block\" onClick={() => onDismiss()}>\n      Close\n    </IonButton>\n  </div>\n);\n\nconst ModalExample: React.FC = () => {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(count + 1);\n  };\n\n  const handleDismiss = () => {\n    dismiss();\n  };\n\n  /**\n   * First parameter is the component to show, second is the props to pass\n   */\n  const [present, dismiss] = useIonModal(Body, {\n    count,\n    onDismiss: handleDismiss,\n    onIncrement: handleIncrement,\n  });\n\n  return (\n    <IonPage>\n      <IonContent fullscreen>\n        <IonButton\n          expand=\"block\"\n          onClick={() => {\n            present({\n              cssClass: 'my-class',\n            });\n          }}\n        >\n          Show Modal\n        </IonButton>\n        <div>Count: {count}</div>\n      </IonContent>\n    </IonPage>\n  );\n};\n```\n\n```tsx\n/* Using with IonModal Component */\n\nimport React, { useState } from 'react';\nimport { IonModal, IonButton, IonContent } from '@ionic/react';\n\nexport const ModalExample: React.FC = () => {\n  const [showModal, setShowModal] = useState(false);\n\n  return (\n    <IonContent>\n      <IonModal isOpen={showModal} cssClass='my-custom-class'>\n        <p>This is modal content</p>\n        <IonButton onClick={() => setShowModal(false)}>Close Modal</IonButton>\n      </IonModal>\n      <IonButton onClick={() => setShowModal(true)}>Show Modal</IonButton>\n    </IonContent>\n  );\n};\n```\n\n#### Card Modals\n\nModals in iOS mode have the ability to be presented in a card-style and swiped to close. The card-style presentation and swipe to close gesture are not mutually exclusive, meaning you can pick and choose which features you want to use. For example, you can have a card-style modal that cannot be swiped or a full sized modal that can be swiped.\n\n> Card style modals when running on iPhone-sized devices do not have backdrops. As a result, the `--backdrop-opacity` variable will not have any effect.\n\n```tsx\nconst App: React.FC = () => {\n  const routerRef = useRef<HTMLIonRouterOutletElement | null>(null);\n  \n  return (\n    <IonApp>\n      <IonReactRouter>\n        <IonRouterOutlet ref={routerRef}>\n          <Route path=\"/home\" render={() => <Home router={routerRef.current} />}  exact={true} />\n        </IonRouterOutlet>\n      </IonReactRouter>\n    </IonApp>\n  )\n};\n\n...\n\ninterface HomePageProps {\n  router: HTMLIonRouterOutletElement | null;\n}\n\nconst Home: React.FC<HomePageProps> = ({ router }) => {\n  const [showModal, setShowModal] = useState(false);\n  \n  return (\n    <IonPage>\n      <IonContent>\n        <IonModal\n          isOpen={showModal}\n          cssClass='my-custom-class'\n          swipeToClose={true}\n          presentingElement={router || undefined}\n          onDidDismiss={() => setShowModal(false)}>\n          <p>This is modal content</p>\n        </IonModal>\n      </IonContent>\n    </IonPage>\n  );\n};\n\n```\n\nIn most scenarios, setting a ref on `IonRouterOutlet` and passing that ref's `current` value to `presentingElement` is fine. In cases where you are presenting a card-style modal from within another modal, you should pass in the top-most `IonModal` ref as the `presentingElement`.\n\n```tsx\n<IonModal\n  ref={firstModalRef}\n  isOpen={showModal}\n  cssClass='my-custom-class'\n  swipeToClose={true}\n  presentingElement={router || undefined}\n  onDidDismiss={() => setShowModal(false)}>\n    <p>This is modal content</p>\n    <IonButton onClick={() => setShow2ndModal(true)}>Show 2nd Modal</IonButton>\n    <IonButton onClick={() => setShowModal(false)}>Close Modal</IonButton>\n</IonModal>\n<IonModal\n  isOpen={show2ndModal}\n  cssClass='my-custom-class'\n  presentingElement={firstModalRef.current}\n  swipeToClose={true}\n  onDidDismiss={() => setShow2ndModal(false)}>\n  <p>This is more modal content</p>\n  <IonButton onClick={() => setShow2ndModal(false)}>Close Modal</IonButton>\n</IonModal>\n```\n\n\n#### Sheet Modals\n\n```tsx\nconst App: React.FC = () => {\n  const routerRef = useRef<HTMLIonRouterOutletElement | null>(null);\n  \n  return (\n    <IonApp>\n      <IonReactRouter>\n        <IonRouterOutlet ref={routerRef}>\n          <Route path=\"/home\" render={() => <Home router={routerRef.current} />}  exact={true} />\n        </IonRouterOutlet>\n      </IonReactRouter>\n    </IonApp>\n  )\n};\n\n...\n\nconst Home: React.FC = () => {\n  const [showModal, setShowModal] = useState(false);\n  \n  return (\n    <IonPage>\n      <IonContent>\n        <IonModal\n          isOpen={showModal}\n          initialBreakpoint={0.5}\n          breakpoints={[0, 0.5, 1]}\n          onDidDismiss={() => setShowModal(false)}>\n          <p>This is modal content</p>\n        </IonModal>\n      </IonContent>\n    </IonPage>\n  );\n};\n\n```\n",
    "stencil": "### Inline Modal\n\n```tsx\nimport { Component, Element, h } from '@stencil/core';\n\n@Component({\n  tag: 'modal-example',\n  styleUrl: 'modal-example.css'\n})\nexport class ModalExample {\n  @Element() el: any;\n  \n  componentDidLoad() {\n    this.routerOutlet = this.el.closest('ion-router-outlet');\n  }\n  \n  render() {\n    return (\n      <div>\n        {/* Default */}\n        <ion-modal isOpen={true}>\n          <ion-content>Modal Content</ion-content>\n        </ion-modal>\n        \n        {/* Use a trigger */}\n        <ion-button id=\"trigger-button\">Click to open modal</ion-button>\n        <ion-modal trigger=\"trigger-button\">\n          <ion-content>Modal Content</ion-content>\n        </ion-modal>\n        \n        {/* Sheet Modal */}\n        <ion-modal\n          isOpen={true}\n          breakpoints={[0.1, 0.5, 1]}\n          initialBreakpoint={0.5}\n        >\n          <ion-content>Modal Content</ion-content>\n        </ion-modal>\n        \n        {/* Card Modal */}\n        <ion-modal\n          isOpen={true}\n          swipeToClose={true}\n          presentingElement={this.routerOutlet}\n        >\n          <ion-content>Modal Content</ion-content>\n        </ion-modal>\n        \n        {/* Passing Props */}\n        <ion-modal isOpen={true}>\n          <app-stencil-component title=\"Ionic\"></app-stencil-component>\n        </ion-modal>\n      </div>\n    )\n  }\n}\n```\n\n### Modal Controller \n\n```tsx\nimport { Component, h } from '@stencil/core';\n\nimport { modalController } from '@ionic/core';\n\n@Component({\n  tag: 'modal-example',\n  styleUrl: 'modal-example.css'\n})\nexport class ModalExample {\n  async presentModal() {\n    const modal = await modalController.create({\n      component: 'page-modal',\n      cssClass: 'my-custom-class'\n    });\n    await modal.present();\n  }\n}\n```\n\n```tsx\nimport { Component, h } from '@stencil/core';\n\n@Component({\n  tag: 'page-modal',\n  styleUrl: 'page-modal.css',\n})\nexport class PageModal {\n  render() {\n    return [\n      <ion-list>\n        <ion-item>\n          <ion-label>Documentation</ion-label>\n        </ion-item>\n        <ion-item>\n          <ion-label>Feedback</ion-label>\n        </ion-item>\n        <ion-item>\n          <ion-label>Settings</ion-label>\n        </ion-item>\n      </ion-list>\n    ];\n  }\n}\n```\n\n> If you need a wrapper element inside of your modal component, we recommend using a `<div class=\"ion-page\">` so that the component dimensions are still computed properly.\n\n### Passing Data\n\nDuring creation of a modal, data can be passed in through the `componentProps`.\nThe previous example can be written to include data:\n\n```tsx\nasync presentModal() {\n  const modal = await modalController.create({\n    component: 'page-modal',\n    cssClass: 'my-custom-class',\n    componentProps: {\n      'firstName': 'Douglas',\n      'lastName': 'Adams',\n      'middleInitial': 'N'\n    }\n  });\n  await modal.present();\n}\n```\n\nTo get the data passed into the `componentProps`, set each one as a `@Prop`:\n\n```tsx\nimport { Component, Prop, h } from '@stencil/core';\n\n@Component({\n  tag: 'page-modal',\n  styleUrl: 'page-modal.css',\n})\nexport class PageModal {\n  // Data passed in by componentProps\n  @Prop() firstName: string;\n  @Prop() lastName: string;\n  @Prop() middleInitial: string;\n}\n```\n\n### Dismissing a Modal\n\nA modal can be dismissed by calling the dismiss method on the modal controller and optionally passing any data from the modal.\n\n```tsx\nexport class ModalPage {\n  ...\n\n  dismiss(data?: any) {\n    // dismiss the closest modal and optionally pass back data\n    (this.el.closest('ion-modal') as any).dismiss({\n      'dismissed': true\n    });\n  }\n}\n```\n\nAfter being dismissed, the data can be read in through the `onWillDismiss` or `onDidDismiss` attached to the modal after creation:\n\n```tsx\nconst { data } = await modal.onWillDismiss();\nconsole.log(data);\n```\n\n### Card Modals\n\nModals in iOS mode have the ability to be presented in a card-style and swiped to close. The card-style presentation and swipe to close gesture are not mutually exclusive, meaning you can pick and choose which features you want to use. For example, you can have a card-style modal that cannot be swiped or a full sized modal that can be swiped.\n\n> Card style modals when running on iPhone-sized devices do not have backdrops. As a result, the `--backdrop-opacity` variable will not have any effect.\n\n```tsx\nimport { Component, Element, h } from '@stencil/core';\n\nimport { modalController } from '@ionic/core';\n\n@Component({\n  tag: 'modal-example',\n  styleUrl: 'modal-example.css'\n})\nexport class ModalExample {\n  @Element() el: any;\n\n  async presentModal() {\n    const modal = await modalController.create({\n      component: 'page-modal',\n      cssClass: 'my-custom-class',\n      swipeToClose: true,\n      presentingElement: this.el.closest('ion-router-outlet'),\n    });\n    await modal.present();\n  }\n\n}\n```\n\nIn most scenarios, using the `ion-router-outlet` element as the `presentingElement` is fine. In cases where you are presenting a card-style modal from within another modal, you should pass in the top-most `ion-modal` element as the `presentingElement`.\n\n```tsx\nasync presentModal() {\n  const modal = await modalController.create({\n    component: 'page-modal',\n    cssClass: 'my-custom-class',\n    swipeToClose: true,\n    presentingElement: await modalController.getTop() // Get the top-most ion-modal\n  });\n  await modal.present();\n}\n```\n\n\n### Sheet Modals\n\n**Controller**\n```tsx\nimport { Component, Element, h } from '@stencil/core';\n\nimport { modalController } from '@ionic/core';\n\n@Component({\n  tag: 'modal-example',\n  styleUrl: 'modal-example.css'\n})\nexport class ModalExample {\n  @Element() el: any;\n\n  async presentModal() {\n    const modal = await modalController.create({\n      component: 'page-modal',\n      initialBreakpoint: 0.5,\n      breakpoints: [0, 0.5, 1]\n      \n    });\n    await modal.present();\n  }\n}\n```\n\n**Inline**\n```tsx\nimport { Component, State, h } from '@stencil/core';\n\n@Component({\n  tag: 'modal-example',\n  styleUrl: 'modal-example.css'\n})\nexport class ModalExample {\n  @State() isModalOpen: boolean = false;\n\n  render() {\n    return [\n      <ion-modal\n        isOpen={isModalOpen} \n        initialBreakpoint={0.5} \n        breakpoints={[0, 0.5, 1]}\n      >\n        <page-modal></page-modal>\n      <ion-modal>\n    ]\n  }\n}\n```\n",
    "vue": "### Inline Modal\n\n```html\n<!-- Default -->\n<ion-modal :is-open=\"true\">\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Use a trigger -->\n<ion-button id=\"trigger-button\">Click to open modal</ion-button>\n<ion-modal trigger=\"trigger-button\">\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Sheet Modal -->\n<ion-modal \n  :is-open=\"true\"\n  :breakpoints=\"[0.1, 0.5, 1]\"\n  :initialBreakpoint=\"0.5\"\n>\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Card Modal -->\n<ion-modal\n  :is-open=\"true\"\n  :swipe-to-close=\"true\"\n  :presenting-element=\"$parent.$refs.ionRouterOutlet\"\n>\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Passing Props -->\n<ion-modal :is-open=\"true\">\n  <app-vue-component title=\"Ionic\"></app-vue-component>\n</ion-modal>\n\n<script>\n  import { IonModal, IonButton, IonContent } from '@ionic/vue';\n  import { defineComponent } from 'vue';\n  import AppVueComponent from './AppVueComponent.vue'\n  \n  export default defineComponent({\n    components: { IonModal, IonButton, IonContent, AppVueComponent }\n  });\n</script>\n```\n\n### Modal Controller\n\n```html\n<template>\n  <ion-header>\n    <ion-toolbar>\n      <ion-title>{{ title }}</ion-title>\n    </ion-toolbar>\n  </ion-header>\n  <ion-content class=\"ion-padding\">\n    {{ content }}\n  </ion-content>\n</template>\n\n<script>\nimport { IonContent, IonHeader, IonTitle, IonToolbar } from '@ionic/vue';\nimport { defineComponent } from 'vue';\n\nexport default defineComponent({\n  name: 'Modal',\n  props: {\n    title: { type: String, default: 'Super Modal' },\n  },\n  data() {\n    return {\n      content: 'Content',\n    }\n  },\n  components: { IonContent, IonHeader, IonTitle, IonToolbar }\n});\n</script>\n```\n\n```html\n<template>\n  <ion-page>\n    <ion-content class=\"ion-padding\">\n      <ion-button @click=\"openModal\">Open Modal</ion-button>\n    </ion-content>\n  </ion-page>\n</template>\n\n<script>\nimport { IonButton, IonContent, IonPage, modalController } from '@ionic/vue';\nimport Modal from './modal.vue'\n\nexport default {\n  components: { IonButton, IonContent, IonPage },\n  methods: {\n    async openModal() {\n      const modal = await modalController\n        .create({\n          component: Modal,\n          cssClass: 'my-custom-class',\n          componentProps: {\n            title: 'New Title'\n          },\n        })\n      return modal.present();\n    },\n  },\n}\n</script>\n```\n\nDevelopers can also use this component directly in their template:\n\n```html\n<template>\n  <ion-button @click=\"setOpen(true)\">Show Modal</ion-button>\n  <ion-modal\n    :is-open=\"isOpenRef\"\n    css-class=\"my-custom-class\"\n    @didDismiss=\"setOpen(false)\"\n  >\n    <Modal :data=\"data\"></Modal>\n  </ion-modal>\n</template>\n\n<script>\nimport { IonModal, IonButton } from '@ionic/vue';\nimport { defineComponent, ref } from 'vue';\nimport Modal from './modal.vue'\n\nexport default defineComponent({\n  components: { IonModal, IonButton, Modal },\n  setup() {\n    const isOpenRef = ref(false);\n    const setOpen = (state: boolean) => isOpenRef.value = state;\n    const data = { content: 'New Content' };\n    return { isOpenRef, setOpen, data }\n  }\n});\n</script>\n```\n\n> If you need a wrapper element inside of your modal component, we recommend using an `<ion-page>` so that the component dimensions are still computed properly.\n\n#### Card Modals\n\nModals in iOS mode have the ability to be presented in a card-style and swiped to close. The card-style presentation and swipe to close gesture are not mutually exclusive, meaning you can pick and choose which features you want to use. For example, you can have a card-style modal that cannot be swiped or a full sized modal that can be swiped.\n\n> Card style modals when running on iPhone-sized devices do not have backdrops. As a result, the `--backdrop-opacity` variable will not have any effect.\n\n```html\n<template>\n  <ion-page>\n    <ion-content>\n      <ion-button @click=\"setOpen(true)\">Show Modal</ion-button>\n      <ion-modal\n        :is-open=\"isOpenRef\"\n        css-class=\"my-custom-class\"\n        :swipe-to-close=\"true\"\n        :presenting-element=\"$parent.$refs.ionRouterOutlet\"\n        @didDismiss=\"setOpen(false)\"\n      >\n        <Modal :data=\"data\"></Modal>\n      </ion-modal>\n    </ion-content>\n  </ion-page>\n</template>\n\n<script lang=\"ts\">\nimport { IonModal, IonButton, IonContent, IonPage } from '@ionic/vue';\nimport { defineComponent, ref } from 'vue';\nimport Modal from './modal.vue'\n\nexport default defineComponent({\n  components: { IonModal, IonButton, Modal, IonContent, IonPage },\n  setup() {\n    const isOpenRef = ref(false);\n    const setOpen = (state: boolean) => isOpenRef.value = state;\n    const data = { content: 'New Content' };\n    return { isOpenRef, setOpen, data }\n  }\n});\n</script>\n```\n\n#### Sheet Modals\n\n```html\n<template>\n  <ion-page>\n    <ion-content class=\"ion-padding\">\n      <ion-button @click=\"openModal()\">Open Modal</ion-button>\n    </ion-content>\n  </ion-page>\n</template>\n\n<script>\nimport { IonButton, IonContent, IonPage, modalController } from '@ionic/vue';\nimport Modal from './modal.vue'\n\nexport default {\n  components: { IonButton, IonContent, IonPage },\n  methods: {\n    async openModal() {\n      const modal = await modalController\n        .create({\n          component: Modal,\n          initialBreakpoint: 0.5,\n          breakpoints: [0, 0.5, 1]\n        })\n      return modal.present();\n    },\n  },\n}\n</script>\n```"
  },
  "props": [
    {
      "name": "animated",
      "type": "boolean",
      "mutable": false,
      "attr": "animated",
      "reflectToAttr": false,
      "docs": "If `true`, the modal will animate.",
      "docsTags": [],
      "default": "true",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "backdropBreakpoint",
      "type": "number",
      "mutable": false,
      "attr": "backdrop-breakpoint",
      "reflectToAttr": false,
      "docs": "A decimal value between 0 and 1 that indicates the\npoint after which the backdrop will begin to fade in\nwhen using a sheet modal. Prior to this point, the\nbackdrop will be hidden and the content underneath\nthe sheet can be interacted with. This value is exclusive\nmeaning the backdrop will become active after the value\nspecified.",
      "docsTags": [],
      "default": "0",
      "values": [
        {
          "type": "number"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "backdropDismiss",
      "type": "boolean",
      "mutable": false,
      "attr": "backdrop-dismiss",
      "reflectToAttr": false,
      "docs": "If `true`, the modal will be dismissed when the backdrop is clicked.",
      "docsTags": [],
      "default": "true",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "breakpoints",
      "type": "number[] | undefined",
      "mutable": false,
      "reflectToAttr": false,
      "docs": "The breakpoints to use when creating a sheet modal. Each value in the\narray must be a decimal between 0 and 1 where 0 indicates the modal is fully\nclosed and 1 indicates the modal is fully open. Values are relative\nto the height of the modal, not the height of the screen. One of the values in this\narray must be the value of the `initialBreakpoint` property.\nFor example: [0, .25, .5, 1]",
      "docsTags": [],
      "values": [
        {
          "type": "number[]"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "enterAnimation",
      "type": "((baseEl: any, opts?: any) => Animation) | undefined",
      "mutable": false,
      "reflectToAttr": false,
      "docs": "Animation to use when the modal is presented.",
      "docsTags": [],
      "values": [
        {
          "type": "((baseEl: any, opts?: any) => Animation)"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "handle",
      "type": "boolean | undefined",
      "mutable": false,
      "attr": "handle",
      "reflectToAttr": false,
      "docs": "The horizontal line that displays at the top of a sheet modal. It is `true` by default when\nsetting the `breakpoints` and `initialBreakpoint` properties.",
      "docsTags": [],
      "values": [
        {
          "type": "boolean"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "htmlAttributes",
      "type": "ModalAttributes | undefined",
      "mutable": false,
      "reflectToAttr": false,
      "docs": "Additional attributes to pass to the modal.",
      "docsTags": [],
      "values": [
        {
          "type": "ModalAttributes"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "initialBreakpoint",
      "type": "number | undefined",
      "mutable": false,
      "attr": "initial-breakpoint",
      "reflectToAttr": false,
      "docs": "A decimal value between 0 and 1 that indicates the\ninitial point the modal will open at when creating a\nsheet modal. This value must also be listed in the\n`breakpoints` array.",
      "docsTags": [],
      "values": [
        {
          "type": "number"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "isOpen",
      "type": "boolean",
      "mutable": false,
      "attr": "is-open",
      "reflectToAttr": false,
      "docs": "If `true`, the modal will open. If `false`, the modal will close.\nUse this if you need finer grained control over presentation, otherwise\njust use the modalController or the `trigger` property.\nNote: `isOpen` will not automatically be set back to `false` when\nthe modal dismisses. You will need to do that in your code.",
      "docsTags": [],
      "default": "false",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "keyboardClose",
      "type": "boolean",
      "mutable": false,
      "attr": "keyboard-close",
      "reflectToAttr": false,
      "docs": "If `true`, the keyboard will be automatically dismissed when the overlay is presented.",
      "docsTags": [],
      "default": "true",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "leaveAnimation",
      "type": "((baseEl: any, opts?: any) => Animation) | undefined",
      "mutable": false,
      "reflectToAttr": false,
      "docs": "Animation to use when the modal is dismissed.",
      "docsTags": [],
      "values": [
        {
          "type": "((baseEl: any, opts?: any) => Animation)"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "mode",
      "type": "\"ios\" | \"md\"",
      "mutable": false,
      "attr": "mode",
      "reflectToAttr": false,
      "docs": "The mode determines which platform styles to use.",
      "docsTags": [],
      "values": [
        {
          "value": "ios",
          "type": "string"
        },
        {
          "value": "md",
          "type": "string"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "presentingElement",
      "type": "HTMLElement | undefined",
      "mutable": false,
      "reflectToAttr": false,
      "docs": "The element that presented the modal. This is used for card presentation effects\nand for stacking multiple modals on top of each other. Only applies in iOS mode.",
      "docsTags": [],
      "values": [
        {
          "type": "HTMLElement"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "showBackdrop",
      "type": "boolean",
      "mutable": false,
      "attr": "show-backdrop",
      "reflectToAttr": false,
      "docs": "If `true`, a backdrop will be displayed behind the modal.",
      "docsTags": [],
      "default": "true",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "swipeToClose",
      "type": "boolean",
      "mutable": false,
      "attr": "swipe-to-close",
      "reflectToAttr": false,
      "docs": "If `true`, the modal can be swiped to dismiss. Only applies in iOS mode.",
      "docsTags": [],
      "default": "false",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "trigger",
      "type": "string | undefined",
      "mutable": false,
      "attr": "trigger",
      "reflectToAttr": false,
      "docs": "An ID corresponding to the trigger element that\ncauses the modal to open when clicked.",
      "docsTags": [],
      "values": [
        {
          "type": "string"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": false,
      "required": false
    }
  ],
  "methods": [
    {
      "name": "dismiss",
      "returns": {
        "type": "Promise<boolean>",
        "docs": ""
      },
      "signature": "dismiss(data?: any, role?: string | undefined) => Promise<boolean>",
      "parameters": [],
      "docs": "Dismiss the modal overlay after it has been presented.",
      "docsTags": [
        {
          "name": "param",
          "text": "data Any data to emit in the dismiss events."
        },
        {
          "name": "param",
          "text": "role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'."
        }
      ]
    },
    {
      "name": "onDidDismiss",
      "returns": {
        "type": "Promise<OverlayEventDetail<T>>",
        "docs": ""
      },
      "signature": "onDidDismiss<T = any>() => Promise<OverlayEventDetail<T>>",
      "parameters": [],
      "docs": "Returns a promise that resolves when the modal did dismiss.",
      "docsTags": []
    },
    {
      "name": "onWillDismiss",
      "returns": {
        "type": "Promise<OverlayEventDetail<T>>",
        "docs": ""
      },
      "signature": "onWillDismiss<T = any>() => Promise<OverlayEventDetail<T>>",
      "parameters": [],
      "docs": "Returns a promise that resolves when the modal will dismiss.",
      "docsTags": []
    },
    {
      "name": "present",
      "returns": {
        "type": "Promise<void>",
        "docs": ""
      },
      "signature": "present() => Promise<void>",
      "parameters": [],
      "docs": "Present the modal overlay after it has been created.",
      "docsTags": []
    }
  ],
  "events": [
    {
      "event": "didDismiss",
      "detail": "OverlayEventDetail<any>",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted after the modal has dismissed.\nShorthand for ionModalDidDismiss.",
      "docsTags": []
    },
    {
      "event": "didPresent",
      "detail": "void",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted after the modal has presented.\nShorthand for ionModalWillDismiss.",
      "docsTags": []
    },
    {
      "event": "ionModalDidDismiss",
      "detail": "OverlayEventDetail<any>",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted after the modal has dismissed.",
      "docsTags": []
    },
    {
      "event": "ionModalDidPresent",
      "detail": "void",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted after the modal has presented.",
      "docsTags": []
    },
    {
      "event": "ionModalWillDismiss",
      "detail": "OverlayEventDetail<any>",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted before the modal has dismissed.",
      "docsTags": []
    },
    {
      "event": "ionModalWillPresent",
      "detail": "void",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted before the modal has presented.",
      "docsTags": []
    },
    {
      "event": "willDismiss",
      "detail": "OverlayEventDetail<any>",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted before the modal has dismissed.\nShorthand for ionModalWillDismiss.",
      "docsTags": []
    },
    {
      "event": "willPresent",
      "detail": "void",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted before the modal has presented.\nShorthand for ionModalWillPresent.",
      "docsTags": []
    }
  ],
  "listeners": [],
  "styles": [
    {
      "name": "--backdrop-opacity",
      "annotation": "prop",
      "docs": "Opacity of the backdrop"
    },
    {
      "name": "--background",
      "annotation": "prop",
      "docs": "Background of the modal content"
    },
    {
      "name": "--border-color",
      "annotation": "prop",
      "docs": "Border color of the modal content"
    },
    {
      "name": "--border-radius",
      "annotation": "prop",
      "docs": "Border radius of the modal content"
    },
    {
      "name": "--border-style",
      "annotation": "prop",
      "docs": "Border style of the modal content"
    },
    {
      "name": "--border-width",
      "annotation": "prop",
      "docs": "Border width of the modal content"
    },
    {
      "name": "--height",
      "annotation": "prop",
      "docs": "Height of the modal"
    },
    {
      "name": "--max-height",
      "annotation": "prop",
      "docs": "Maximum height of the modal"
    },
    {
      "name": "--max-width",
      "annotation": "prop",
      "docs": "Maximum width of the modal"
    },
    {
      "name": "--min-height",
      "annotation": "prop",
      "docs": "Minimum height of the modal"
    },
    {
      "name": "--min-width",
      "annotation": "prop",
      "docs": "Minimum width of the modal"
    },
    {
      "name": "--width",
      "annotation": "prop",
      "docs": "Width of the modal"
    }
  ],
  "slots": [
    {
      "name": "= Content is placed inside of the `.modal-content` element.",
      "docs": ""
    }
  ],
  "parts": [
    {
      "name": "backdrop",
      "docs": "The `ion-backdrop` element."
    },
    {
      "name": "content",
      "docs": "The wrapper element for the default slot."
    },
    {
      "name": "handle",
      "docs": "The handle that is displayed at the top of the sheet modal when `handle=\"true\"`."
    }
  ],
  "dependents": [],
  "dependencies": [
    "ion-backdrop"
  ],
  "dependencyGraph": {
    "ion-modal": [
      "ion-backdrop"
    ]
  }
}