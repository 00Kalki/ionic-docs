{
  "filePath": "./src/components/modal/modal.tsx",
  "encapsulation": "shadow",
  "tag": "ion-modal",
  "readme": "# ion-modal\n\nA Modal is a dialog that appears on top of the app's content, and must be dismissed by the app before interaction can resume. It is useful as a select component when there are a lot of options to choose from, or when filtering items in a list, as well as many other use cases.\n\n## Presenting\n\nThere are two ways to use `ion-modal`: inline or via the `modalController`. Each method comes with different considerations, so be sure to use the approach that best fits your use case.\n\n## Inline Modals\n\n`ion-modal` can be used by writing the component directly in your template. This reduces the number of handlers you need to wire up in order to present the modal. See [Usage](#usage) for an example of how to write a modal inline. \n\nWhen using `ion-modal` with Angular, React, or Vue, the component you pass in will be destroyed when the modal is dismissed. As this functionality is provided by the JavaScript framework, using `ion-modal` without a JavaScript framework will not destroy the component you passed in. If this is a needed functionality, we recommend using the `modalController` instead.\n\n### Angular \n\nSince the component you passed in needs to be created when the modal is presented and destroyed when the modal is dismissed, we are unable to project the content using `<ng-content>` internally. Instead, we use `<ng-container>` which expects an `<ng-template>` to be passed in. As a result, when passing in your component you will need to wrap it in an `<ng-template>`:\n\n```html\n<ion-modal [isOpen]=\"isModalOpen\">\n  <ng-template>\n    <app-modal-content></app-modal-content>\n  </ng-template>\n</ion-modal>\n```\n\n### When to use\n\nUsing a modal inline is useful when you do not want to explicitly wire up click events to open the modal. For example, you can use the `is-open` property to easily present or dismiss a modal based on some state in your application.\n\nIf you need fine grained control over when the modal is presented and dismissed, we recommend you use the `modalController`. \n\n## Controller Modals\n\n`ion-modal` can also be presented programmatically by using the `modalController` imported from Ionic Framework. This allows you to have complete control over when a modal is presented above and beyond the customization that inline modals give you. See [Usage](#usage) for an example of how to use the `modalController`.\n\n### When to use\n\nWe typically recommend that you write your modals inline as it streamlines the amount of code in your application. You should only use the `modalController` for complex use cases where writing a modal inline is impractical.\n\n## Card Modal\n\nDevelopers can create a card modal effect where the modal appears as a card stacked on top of your app's main content. To create a card modal, developers need to set the `presentingElement` property and the `swipeToClose` properties on `ion-modal`.\n\nThe `presentingElement` property accepts a reference to the element that should display under your modal. This is typically a reference to `ion-router-outlet`.\n\nThe `swipeToClose` property can be used to control whether or not the card modal can be swiped to close.\n\nSee [Usage](#usage) for examples on how to use the sheet modal.\n\n## Sheet Modal\n\nDevelopers can create a sheet modal effect similar to the drawer components available in maps applications. To create a sheet modal, developers need to set the `breakpoints` and `initialBreakpoint` properties on `ion-modal`.\n\nThe `breakpoints` property accepts an array which states each breakpoint that the sheet can snap to when swiped. A `breakpoints` property of `[0, 0.5, 1]` would indicate that the sheet can be swiped to show 0% of the modal, 50% of the modal, and 100% of the modal. When the modal is swiped to 0%, the modal will be automatically dismissed.\n\nThe `initialBreakpoint` property is required so that the sheet modal knows which breakpoint to start at when presenting. The `initialBreakpoint` value must also exist in the `breakpoints` array. Given a `breakpoints` value of `[0, 0.5, 1]`, an `initialBreakpoint` value of `0.5` would be valid as `0.5` is in the `breakpoints` array. An `initialBreakpoint` value of `0.25` would not be valid as `0.25` does not exist in the `breakpoints` array.\n\nThe `backdropBreakpoint` property can be used to customize the point at which the `ion-backdrop` will begin to fade in. This is useful when creating interfaces that have content underneath the sheet that should remain interactive. A common use case is a sheet modal that overlays a map where the map is interactive until the sheet is fully expanded.\n\nSee [Usage](#usage) for examples on how to use the sheet modal.\n\n> Note: The `swipeToClose` property has no effect when using a sheet modal as sheet modals must be swipeable in order to be usable.\n\n## Preventing a Modal from Dismissing\n\nWhen entering data into a modal, it is often desirable to have a way of preventing accidental data loss. The `canDismiss` property on `ion-modal` gives developers control over when a modal is allowed to dismiss.\n\nThere are two different ways of using the `canDismiss` property.\n\n> Note: When using a sheet modal, `canDismiss` will not be checked on swipe if there is no `0` breakpoint set. However, it will still be checked when pressing `Esc` or the hardware back button.\n\n### Setting a boolean value\n\nDevelopers can set `canDismiss` to a boolean value. If `canDismiss` is `true`, then the modal will close when users attempt to dismiss the modal. If `canDismiss` is `false`, then the modal will not close when users attempt to dismiss the modal.\n\nSetting a boolean value should be used when you need to require a particular action to be taken prior to a modal being dismissed. For example, if developers want to require that a \"Terms of Use\" checkbox is checked prior to closing the modal, they could set `canDismiss` to `false` initially and update it to `true` when the checkbox is checked.\n\n### Setting a callback function\n\nDevelopers can set `canDismiss` to be a function. This function must return a `Promise` that resolves to either `true` or `false`. If the promise resolves to `true`, then the modal will dismiss. If the promise resolves to `false`, then the modal will not dismiss.\n\nSetting a callback function should be used when you have complex dismissing criteria such as showing a confirmation dialog prior to dismissing the modal. The option that users select in this dialog can then be used to determine whether or not the modal should proceed with dismissing.\n\nNote that setting a callback function will cause the swipe gesture to be interrupted when using a card or sheet modal. This is because Ionic does not know what your callback function will resolve to ahead of time.\n\n## Interfaces\n\n### ModalOptions\n\nBelow you will find all of the options available to you when using the `modalController`. These options should be supplied when calling `modalController.create()`.\n\n```typescript\ninterface ModalOptions {\n  component: any;\n  componentProps?: { [key: string]: any };\n  presentingElement?: HTMLElement;\n  showBackdrop?: boolean;\n  backdropDismiss?: boolean;\n  cssClass?: string | string[];\n  animated?: boolean;\n  swipeToClose?: boolean;\n\n  mode?: 'ios' | 'md';\n  keyboardClose?: boolean;\n  id?: string;\n\n  enterAnimation?: AnimationBuilder;\n  leaveAnimation?: AnimationBuilder;\n}\n```\n### ModalCustomEvent\n\nWhile not required, this interface can be used in place of the `CustomEvent` interface for stronger typing with Ionic events emitted from this component.\n\n```typescript\ninterface ModalCustomEvent extends CustomEvent {\n  target: HTMLIonModalElement;\n}\n```\n\n## Dismissing\n\nThe modal can be dismissed after creation by calling the `dismiss()` method on the modal controller. The `onDidDismiss` function can be called to perform an action after the modal is dismissed.\n\n## Styling\n\nModals are presented at the root of your application so they overlay your entire app. This behavior applies to both inline modals and modals presented from a controller. As a result, custom modal styles can not be scoped to a particular component as they will not apply to the modal. Instead, styles must be applied globally. For most developers, placing the custom styles in `global.css` is sufficient.\n\n> If you are building an Ionic Angular app, the styles need to be added to a global stylesheet file. Read [Style Placement](#style-placement) in the Angular section below for more information.\n\n> `ion-modal` works under the assumption that stacked modals are the same size. As a result, each subsequent modal will have no box shadow and a backdrop opacity of `0`. This is to avoid the effect of shadows and backdrops getting darker with each added modal. This can be changed by setting the `--box-shadow` and `--backdrop-opacity` CSS variables:\n``` \nion-modal.stack-modal {\n  --box-shadow: 0 28px 48px rgba(0, 0, 0, 0.4);\n  --backdrop-opacity: var(--ion-backdrop-opacity, 0.32);\n}\n```\n\n## Interfaces\n\n### ModalOptions\n\n```typescript\ninterface ModalOptions<T extends ComponentRef = ComponentRef> {\n  component: T;\n  componentProps?: ComponentProps<T>;\n  presentingElement?: HTMLElement;\n  showBackdrop?: boolean;\n  backdropDismiss?: boolean;\n  cssClass?: string | string[];\n  animated?: boolean;\n  swipeToClose?: boolean;\n\n  mode?: Mode;\n  keyboardClose?: boolean;\n  id?: string;\n  htmlAttributes?: { [key: string]: any };\n\n  enterAnimation?: AnimationBuilder;\n  leaveAnimation?: AnimationBuilder;\n\n  breakpoints?: number[];\n  initialBreakpoint?: number;\n  backdropBreakpoint?: number;\n  handle?: boolean;\n}\n```\n\n\n## Accessibility\n\n### Keyboard Navigation\n\n| Key   | Function            |\n| ----- | ------------------- |\n| `Esc` | Dismisses the modal |\n\n### Screen Readers\n\nModals have the `aria-modal` attribute applied. This attribute can cause assistive technologies to limit navigation to the modal element's contents. As a result, using gestures that move to the next or previous items may not focus elements outside of the modal. This applies even when the backdrop is disabled in sheet modals using the `backdropBreakpoint` property.\n\nAssistive technologies will not limit navigation to the modal element's contents if developers manually move focus. However, manually moving focus outside of a modal is not supported in Ionic for modals that have focus trapping enabled.\n\nSee https://w3c.github.io/aria/#aria-modal for more information.\n\n### Focus Trapping\n\nWhen a modal is presented, focus will be trapped inside of the presented modal. Users can focus other interactive elements inside the modal but will never be able to focus interactive elements outside the modal while the modal is presented. For applications that present multiple stacked modals, focus will be trapped on the modal that was presented last.\n\nSheet modals that have had their backdrop disabled by the `backdropBreakpoint` property are not subject to focus trapping.\n\n### Sheet Modals\n\nSheet modals allow users to interact with content behind the modal when the `backdropBreakpoint` property is used. The backdrop will be disabled up to and including the specified `backdropBreakpoint` and will be enabled after it.\n\nWhen the backdrop is disabled, users will be able to interact with elements outside the sheet modal using a pointer or keyboard. Assistive technologies may not focus outside the sheet modal by default due to the usage of `aria-modal`. We recommend avoiding features such as autofocus here as it can cause assistive technologies to jump between two interactive contexts without warning the user.  \n",
  "docs": "A Modal is a dialog that appears on top of the app's content, and must be dismissed by the app before interaction can resume. It is useful as a select component when there are a lot of options to choose from, or when filtering items in a list, as well as many other use cases.",
  "docsTags": [
    {
      "name": "virtualProp",
      "text": "{\"ios\" | \"md\"} mode - The mode determines which platform styles to use."
    },
    {
      "name": "slot",
      "text": "- Content is placed inside of the `.modal-content` element."
    },
    {
      "name": "part",
      "text": "backdrop - The `ion-backdrop` element."
    },
    {
      "name": "part",
      "text": "content - The wrapper element for the default slot."
    },
    {
      "name": "part",
      "text": "handle - The handle that is displayed at the top of the sheet modal when `handle=\"true\"`."
    }
  ],
  "usage": {
    "angular": "### Inline Modal\n\n```html\n<!-- Default -->\n<ion-modal [isOpen]=\"true\">\n  <ng-template>\n    <ion-content>Modal Content</ion-content>\n  </ng-template>\n</ion-modal>\n\n<!-- Use a trigger -->\n<ion-button id=\"trigger-button\">Click to open modal</ion-button>\n<ion-modal trigger=\"trigger-button\">\n  <ng-template>\n    <ion-content>Modal Content</ion-content>\n  </ng-template>\n</ion-modal>\n\n<!-- Sheet Modal -->\n<ion-modal\n  [isOpen]=\"true\"\n  [breakpoints]=\"[0.1, 0.5, 1]\"\n  [initialBreakpoint]=\"0.5\"\n>\n  <ng-template>\n    <ion-content>Modal Content</ion-content>\n  </ng-template>\n</ion-modal>\n\n<!-- Card Modal -->\n<ion-modal\n  [isOpen]=\"true\"\n  [swipeToClose]=\"true\"\n  [presentingElement]=\"routerOutlet.nativeEl\"\n>\n  <ng-template>\n    <ion-content>Modal Content</ion-content>\n  </ng-template>\n</ion-modal>\n\n<!-- Passing Props -->\n<ion-modal [isOpen]=\"true\">\n  <ng-template>\n    <app-angular-component title=\"Ionic\"></app-angular-component>\n  </ng-template>\n</ion-modal>\n\n<!-- Require Action Sheet confirmation before dismissing -->\n<ion-modal [isOpen]=\"true\" [canDismiss]=\"canDismiss\">\n  <ng-template>\n    <ion-content>Modal Content</ion-content>\n  </ng-template>\n</ion-modal>\n```\n\n```typescript\nimport { Component } from '@angular/core';\nimport { IonRouterOutlet, ActionSheetController } from '@ionic/angular';\n\n@Component({\n  selector: 'modal-example',\n  templateUrl: 'modal-example.html',\n  styleUrls: ['./modal-example.css']\n})\nexport class ModalExample {\n  constructor(\n    public routerOutlet: IonRouterOutlet,\n    private actionSheetCtrl: ActionSheetController\n  ) {}\n\n  async canDismiss() {\n    const actionSheet = await this.actionSheetCtrl.create({\n      header: 'Are you sure you want to discard your changes?',\n      buttons: [\n        {\n          text: 'Discard Changes',\n          role: 'destructive'\n        },\n        {\n          text: 'Keep Editing',\n          role: 'cancel'\n        }\n      ]\n    });\n    \n    await actionSheet.present();\n\n    const { role } = await actionSheet.onDidDismiss();\n    \n    if (role === 'destructive') {\n      return true;\n    }\n\n    return false;\n  }\n}\n```\n\n### Modal Controller\n\n```typescript\nimport { Component } from '@angular/core';\nimport { ModalController } from '@ionic/angular';\nimport { ModalPage } from '../modal/modal.page';\n\n@Component({\n  selector: 'modal-example',\n  templateUrl: 'modal-example.html',\n  styleUrls: ['./modal-example.css']\n})\nexport class ModalExample {\n  // The `ion-modal` element reference.\n  modal: HTMLElement;\n\n  constructor(public modalController: ModalController) {}\n\n  async presentModal() {\n    const modal = await this.modalController.create({\n      component: ModalPage,\n      cssClass: 'my-custom-class'\n    });\n    return await modal.present();\n  }\n}\n```\n\n```typescript\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'modal-page',\n})\nexport class ModalPage {\n\n  constructor() {}\n\n}\n```\n\n> If you need a wrapper element inside of your modal component, we recommend using a `<div class=\"ion-page\">` so that the component dimensions are still computed properly.\n\n#### Passing Data\n\nDuring creation of a modal, data can be passed in through the `componentProps`.\nThe previous example can be written to include data:\n\n```typescript\nasync presentModal() {\n  const modal = await this.modalController.create({\n    component: ModalPage,\n    cssClass: 'my-custom-class',\n    componentProps: {\n      'firstName': 'Douglas',\n      'lastName': 'Adams',\n      'middleInitial': 'N'\n    }\n  });\n  return await modal.present();\n}\n```\n\nTo get the data passed into the `componentProps`, set it as an `@Input`:\n\n```typescript\nexport class ModalPage {\n\n  // Data passed in by componentProps\n  @Input() firstName: string;\n  @Input() lastName: string;\n  @Input() middleInitial: string;\n\n}\n```\n\n#### Dismissing a Modal\n\nA modal can be dismissed by calling the dismiss method on the modal controller and optionally passing any data from the modal.\n\n```javascript\nexport class ModalPage {\n  ...\n\n  dismiss() {\n    // using the injected ModalController this page\n    // can \"dismiss\" itself and optionally pass back data\n    this.modalController.dismiss({\n      'dismissed': true\n    });\n  }\n}\n```\n\nAfter being dismissed, the data can be read in through the `onWillDismiss` or `onDidDismiss` attached to the modal after creation:\n\n```javascript\nconst { data } = await modal.onWillDismiss();\nconsole.log(data);\n```\n\n#### Accessing the Modal Element\n\nWhen opening a modal with the modal controller, Ionic will assign the modal HTML element reference to the `modal` property on your component's class instance.\n\nYou can use this property to directly access the `ion-modal` element to add or remove classes or handle additional checks.\n\n```ts\nexport class ModalPage implements OnInit {\n  // The `ion-modal` element reference.\n  modal: HTMLElement;\n\n  ngOnInit() {\n    console.log('The HTML ion-modal element', this.modal); // <ion-modal></ion-modal>\n  }\n}\n```\n\n#### Lazy Loading\n\nWhen lazy loading a modal, it's important to note that the modal will not be loaded when it is opened, but rather when the module that imports the modal's module is loaded.\n\nFor example, say there exists a `CalendarComponent` and an `EventModal`. The modal is presented by clicking a button in the `CalendarComponent`. In Angular, the `EventModalModule` would need to be included in the `CalendarComponentModule` since the modal is created in the `CalendarComponent`:\n\n```typescript\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule } from '@ionic/angular';\n\nimport { CalendarComponent } from './calendar.component';\nimport { EventModalModule } from '../modals/event/event.module';\n\n@NgModule({\n  declarations: [\n    CalendarComponent\n  ],\n  imports: [\n    IonicModule,\n    CommonModule,\n    EventModalModule\n  ],\n  exports: [\n    CalendarComponent\n  ]\n})\n\nexport class CalendarComponentModule {}\n```\n\n#### Card Modals\n\nModals in iOS mode have the ability to be presented in a card-style and swiped to close. The card-style presentation and swipe to close gesture are not mutually exclusive, meaning you can pick and choose which features you want to use. For example, you can have a card-style modal that cannot be swiped or a full sized modal that can be swiped.\n\n> Card style modals when running on iPhone-sized devices do not have backdrops. As a result, the `--backdrop-opacity` variable will not have any effect.\n\nIf you are creating an application that uses `ion-tabs`, it is recommended that you get the parent `ion-router-outlet` using `this.routerOutlet.parentOutlet.nativeEl`, otherwise the tabbar will not scale down when the modal opens.\n\n```javascript\nimport { IonRouterOutlet } from '@ionic/angular';\n\nconstructor(private routerOutlet: IonRouterOutlet) {}\n\nasync presentModal() {\n  const modal = await this.modalController.create({\n    component: ModalPage,\n    cssClass: 'my-custom-class',\n    swipeToClose: true,\n    presentingElement: this.routerOutlet.nativeEl\n  });\n  return await modal.present();\n}\n```\n\nIn most scenarios, using the `ion-router-outlet` element as the `presentingElement` is fine. In cases where you are presenting a card-style modal from within another modal, you should pass in the top-most `ion-modal` element as the `presentingElement`.\n\n```javascript\nimport { ModalController } from '@ionic/angular';\n\nconstructor(private modalController: ModalController) {}\n\nasync presentModal() {\n  const modal = await this.modalController.create({\n    component: ModalPage,\n    cssClass: 'my-custom-class',\n    swipeToClose: true,\n    presentingElement: await this.modalController.getTop() // Get the top-most ion-modal\n  });\n  return await modal.present();\n}\n```\n\n#### Sheet Modals\n\n```javascript\nimport { IonRouterOutlet } from '@ionic/angular';\n\nconstructor(private routerOutlet: IonRouterOutlet) {}\n\nasync presentModal() {\n  const modal = await this.modalController.create({\n    component: ModalPage,\n    initialBreakpoint: 0.5,\n    breakpoints: [0, 0.5, 1]\n  });\n  return await modal.present();\n}\n```\n\n### Style Placement\n\nIn Angular, the CSS of a specific page is scoped only to elements of that page. Even though the Modal can be presented from within a page, the `ion-modal` element is appended outside of the current page. This means that any custom styles need to go in a global stylesheet file. In an Ionic Angular starter this can be the `src/global.scss` file or you can register a new global style file by [adding to the `styles` build option in `angular.json`](https://angular.io/guide/workspace-config#style-script-config).",
    "javascript": "### Inline Modal\n\n```html\n<ion-app>\n  <!-- Default -->\n  <ion-modal is-open=\"true\">\n    <ion-content>Modal Content</ion-content>\n  </ion-modal>\n  \n  <!-- Use a trigger -->\n  <ion-button id=\"trigger-button\">Click to open modal</ion-button>\n  <ion-modal trigger=\"trigger-button\">\n    <ion-content>Modal Content</ion-content>\n  </ion-modal>\n  \n  <!-- Sheet Modal -->\n  <ion-modal is-open=\"true\" id=\"sheet-modal\">\n    <ion-content>Modal Content</ion-content>\n  </ion-modal>\n  \n  <!-- Card Modal -->\n  <ion-modal is-open=\"true\" id=\"card-modal\">\n    <ion-content>Modal Content</ion-content>\n  </ion-modal>\n  \n  <!-- Require Action Sheet confirmation before dismissing -->\n  <ion-modal is-open=\"true\" id=\"can-dismiss-modal\">\n    <ion-content>Modal Content</ion-content>\n  </ion-modal>\n</ion-app>\n\n<script>\n  const sheetModal = document.querySelector('#sheet-modal');\n  const cardModal = document.querySelector('#sheet-modal');\n  const canDismissModal = document.querySelector('#can-dismiss-modal');\n  const app = document.querySelector('ion-app');\n\n  sheetModal.breakpoints = [0.1, 0.5, 1];\n  sheetModal.initialBreakpoint = 0.5;\n  \n  cardModal.swipeToClose = true;\n  cardModal.presentingElement = document.querySelector('ion-app');\n  \n  canDismissModal.canDismiss = async () => {\n    const actionSheet = document.createElement('ion-action-sheet');\n    \n    actionSheet.header = 'Are you sure you want to discard your changes?';\n    actionSheet.buttons = [\n      {\n        text: 'Discard Changes',\n        role: 'destructive'\n      },\n      {\n        text: 'Keep Editing',\n        role: 'cancel'\n      }\n    ];\n    \n    app.appendChild(actionSheet);\n    \n    await actionSheet.present();\n            \n    const { role } = await actionSheet.onDidDismiss();\n    \n    if (role === 'destructive') {\n      return true;\n    }\n    \n    return false;    \n  }\n</script>\n```\n\n### Using JavaScript\n\n```javascript\ncustomElements.define('modal-page', class extends HTMLElement {\n  connectedCallback() {\n    this.innerHTML = `\n<ion-header>\n  <ion-toolbar>\n    <ion-title>Modal Header</ion-title>\n    <ion-buttons slot=\"primary\">\n      <ion-button onClick=\"dismissModal()\">\n        <ion-icon slot=\"icon-only\" name=\"close\"></ion-icon>\n      </ion-button>\n    </ion-buttons>\n  </ion-toolbar>\n</ion-header>\n<ion-content class=\"ion-padding\">\n  Modal Content\n</ion-content>`;\n  }\n});\n\nfunction presentModal() {\n  // create the modal with the `modal-page` component\n  const modalElement = document.createElement('ion-modal');\n  modalElement.component = 'modal-page';\n  modalElement.cssClass = 'my-custom-class';\n\n  // present the modal\n  document.body.appendChild(modalElement);\n  return modalElement.present();\n}\n```\n\n> If you need a wrapper element inside of your modal component, we recommend using a `<div class=\"ion-page\">` so that the component dimensions are still computed properly.\n\n### Passing Data\n\nDuring creation of a modal, data can be passed in through the `componentProps`. The previous example can be written to include data:\n\n```javascript\nconst modalElement = document.createElement('ion-modal');\nmodalElement.component = 'modal-page';\nmodalElement.cssClass = 'my-custom-class';\nmodalElement.componentProps = {\n  'firstName': 'Douglas',\n  'lastName': 'Adams',\n  'middleInitial': 'N'\n};\n```\n\nTo get the data passed into the `componentProps`, query for the modal in the `modal-page`:\n\n```js\ncustomElements.define('modal-page', class extends HTMLElement {\n  connectedCallback() {\n    const modalElement = document.querySelector('ion-modal');\n    console.log(modalElement.componentProps.firstName);\n\n    ...\n  }\n}\n```\n\n\n### Dismissing a Modal\n\nA modal can be dismissed by calling the dismiss method and optionally passing any data from the modal.\n\n```javascript\nasync function dismissModal() {\n  await modal.dismiss({\n    'dismissed': true\n  });\n}\n```\n\nAfter being dismissed, the data can be read in through the `onWillDismiss` or `onDidDismiss` attached to the modal after creation:\n\n```javascript\nconst { data } = await modalElement.onWillDismiss();\nconsole.log(data);\n```\n\n\n### Card Modals\n\nModals in iOS mode have the ability to be presented in a card-style and swiped to close. The card-style presentation and swipe to close gesture are not mutually exclusive, meaning you can pick and choose which features you want to use. For example, you can have a card-style modal that cannot be swiped or a full sized modal that can be swiped.\n\n> Card style modals when running on iPhone-sized devices do not have backdrops. As a result, the `--backdrop-opacity` variable will not have any effect.\n\n```javascript\nconst modalElement = document.createElement('ion-modal');\nmodalElement.component = 'modal-page';\nmodalElement.cssClass = 'my-custom-class';\nmodalElement.swipeToClose = true;\nmodalElement.presentingElement = document.querySelector('ion-nav');\n```\n\nIn most scenarios, using the `ion-nav` element as the `presentingElement` is fine. In cases where you are presenting a card-style modal from within a modal, you should pass in the top-most `ion-modal` element as the `presentingElement`.\n\n```javascript\nconst modalElement = document.createElement('ion-modal');\nmodalElement.component = 'modal-page';\nmodalElement.cssClass = 'my-custom-class';\nmodalElement.swipeToClose = true;\nmodalElement.presentingElement = await modalController.getTop(); // Get the top-most ion-modal\n```\n\n### Sheet Modals\n\n```javascript\nconst modalElement = document.createElement('ion-modal');\nmodalElement.component = 'modal-page';\nmodalElement.initialBreakpoint = 0.5;\nmodalElement.breakpoints = [0, 0.5, 1];\n```",
    "react": "### Inline Modal\n\n```tsx\nimport { React, useRef } from 'react';\nconst App: React.FC = () => {\n  const routerRef = useRef<HTMLIonRouterOutletElement | null>(null);\n  \n  return (\n    <IonApp>\n      <IonReactRouter>\n        <IonRouterOutlet ref={routerRef}>\n          <Route path=\"/home\" render={() => <Home router={routerRef.current} />}  exact={true} />\n        </IonRouterOutlet>\n      </IonReactRouter>\n    </IonApp>\n  )\n};\n\n...\n\ninterface Props {\n  router: HTMLIonRouterOutletElement | null;\n}\n\nimport React from 'react';\nimport AppReactComponent from './AppReactComponent';\nimport { IonModal, IonContent, IonButton, useIonActionSheet } from '@ionic/react';\nexport const ModalExample: React.FC<Props> = ({ router }) => {\n  const [present, dismiss] = useIonActionSheet();\n\n  const canDismiss = () => {\n    return new Promise(async (resolve) => {\n      await present({\n        header: 'Are you sure you want to discard your changes?',\n        buttons: [\n          {\n            text: 'Discard Changes',\n            role: 'destructive'\n          },\n          {\n            text: 'Keep Editing',\n            role: 'cancel'\n          }\n        ],\n        onDidDismiss: (ev: CustomEvent) => {\n            const role = ev.detail.role;\n            \n            if (role === 'destructive') {\n              resolve(true);\n            }\n            \n            resolve(false);\n          }\n        });\n      });\n    });\n  }\n\n  return (\n    <>\n      {/* Default */}\n      <IonModal isOpen={true}>\n        <IonContent>Modal Content</IonContent>\n      </IonModal>\n      \n      {/* Use a trigger */}\n      <IonButton id=\"trigger-button\">Click to open modal</IonButton>\n      <IonModal trigger=\"trigger-button\">\n        <IonContent>Modal Content</IonContent>\n      </IonModal>\n      \n      {/* Sheet Modal */}\n      <IonModal\n        isOpen={true}\n        breakpoints={[0.1, 0.5, 1]}\n        initialBreakpoint={0.5}\n      >\n        <IonContent>Modal Content</IonContent>\n      </IonModal>\n      \n      {/* Card Modal */}\n      <IonModal\n        isOpen={true}\n        swipeToClose={true}\n        presentingElement={router || undefined}\n      >\n        <IonContent>Modal Content</IonContent>\n      </IonModal>\n      \n      {/* Passing Props */}\n      <IonModal isOpen={true}>\n        <AppReactComponent title=\"Ionic\"></AppReactComponent>\n      </IonModal>\n      \n      {/* Require Action Sheet confirmation before dismissing */}\n      <IonModal isOpen={true} canDismiss={canDismiss}>\n        <IonContent>Modal Content</IonContent>\n      </IonModal>\n    </>\n  );\n};\n```\n\n\n### useIonModal Hook\n\n> `useIonModal` requires being a descendant of `<IonApp>`. If you need to use a modal outside of an `<IonApp>`, consider using the component method instead.\n\n\n```tsx\n/* Using with useIonModal Hook */ \n\nimport React, { useState } from 'react';\nimport { IonButton, IonContent, IonPage, useIonModal } from '@ionic/react';\n\nconst Body: React.FC<{\n  count: number;\n  onDismiss: () => void;\n  onIncrement: () => void;\n}> = ({ count, onDismiss, onIncrement }) => (\n  <div>\n    count: {count}\n    <IonButton expand=\"block\" onClick={() => onIncrement()}>\n      Increment Count\n    </IonButton>\n    <IonButton expand=\"block\" onClick={() => onDismiss()}>\n      Close\n    </IonButton>\n  </div>\n);\n\nconst ModalExample: React.FC = () => {\n  const [count, setCount] = useState(0);\n\n  const handleIncrement = () => {\n    setCount(count + 1);\n  };\n\n  const handleDismiss = () => {\n    dismiss();\n  };\n\n  /**\n   * First parameter is the component to show, second is the props to pass\n   */\n  const [present, dismiss] = useIonModal(Body, {\n    count,\n    onDismiss: handleDismiss,\n    onIncrement: handleIncrement,\n  });\n\n  return (\n    <IonPage>\n      <IonContent fullscreen>\n        <IonButton\n          expand=\"block\"\n          onClick={() => {\n            present({\n              cssClass: 'my-class',\n            });\n          }}\n        >\n          Show Modal\n        </IonButton>\n        <div>Count: {count}</div>\n      </IonContent>\n    </IonPage>\n  );\n};\n```\n\n```tsx\n/* Using with IonModal Component */\n\nimport React, { useState } from 'react';\nimport { IonModal, IonButton, IonContent } from '@ionic/react';\n\nexport const ModalExample: React.FC = () => {\n  const [showModal, setShowModal] = useState(false);\n\n  return (\n    <IonContent>\n      <IonModal isOpen={showModal} cssClass='my-custom-class'>\n        <p>This is modal content</p>\n        <IonButton onClick={() => setShowModal(false)}>Close Modal</IonButton>\n      </IonModal>\n      <IonButton onClick={() => setShowModal(true)}>Show Modal</IonButton>\n    </IonContent>\n  );\n};\n```\n\n#### Card Modals\n\nModals in iOS mode have the ability to be presented in a card-style and swiped to close. The card-style presentation and swipe to close gesture are not mutually exclusive, meaning you can pick and choose which features you want to use. For example, you can have a card-style modal that cannot be swiped or a full sized modal that can be swiped.\n\n> Card style modals when running on iPhone-sized devices do not have backdrops. As a result, the `--backdrop-opacity` variable will not have any effect.\n\n```tsx\nconst App: React.FC = () => {\n  const routerRef = useRef<HTMLIonRouterOutletElement | null>(null);\n  \n  return (\n    <IonApp>\n      <IonReactRouter>\n        <IonRouterOutlet ref={routerRef}>\n          <Route path=\"/home\" render={() => <Home router={routerRef.current} />}  exact={true} />\n        </IonRouterOutlet>\n      </IonReactRouter>\n    </IonApp>\n  )\n};\n\n...\n\ninterface HomePageProps {\n  router: HTMLIonRouterOutletElement | null;\n}\n\nconst Home: React.FC<HomePageProps> = ({ router }) => {\n  const [showModal, setShowModal] = useState(false);\n  \n  return (\n    <IonPage>\n      <IonContent>\n        <IonModal\n          isOpen={showModal}\n          cssClass='my-custom-class'\n          swipeToClose={true}\n          presentingElement={router || undefined}\n          onDidDismiss={() => setShowModal(false)}>\n          <p>This is modal content</p>\n        </IonModal>\n      </IonContent>\n    </IonPage>\n  );\n};\n\n```\n\nIn most scenarios, setting a ref on `IonRouterOutlet` and passing that ref's `current` value to `presentingElement` is fine. In cases where you are presenting a card-style modal from within another modal, you should pass in the top-most `IonModal` ref as the `presentingElement`.\n\n```tsx\n<IonModal\n  ref={firstModalRef}\n  isOpen={showModal}\n  cssClass='my-custom-class'\n  swipeToClose={true}\n  presentingElement={router || undefined}\n  onDidDismiss={() => setShowModal(false)}>\n    <p>This is modal content</p>\n    <IonButton onClick={() => setShow2ndModal(true)}>Show 2nd Modal</IonButton>\n    <IonButton onClick={() => setShowModal(false)}>Close Modal</IonButton>\n</IonModal>\n<IonModal\n  isOpen={show2ndModal}\n  cssClass='my-custom-class'\n  presentingElement={firstModalRef.current}\n  swipeToClose={true}\n  onDidDismiss={() => setShow2ndModal(false)}>\n  <p>This is more modal content</p>\n  <IonButton onClick={() => setShow2ndModal(false)}>Close Modal</IonButton>\n</IonModal>\n```\n\n\n#### Sheet Modals\n\n```tsx\nconst App: React.FC = () => {\n  const routerRef = useRef<HTMLIonRouterOutletElement | null>(null);\n  \n  return (\n    <IonApp>\n      <IonReactRouter>\n        <IonRouterOutlet ref={routerRef}>\n          <Route path=\"/home\" render={() => <Home router={routerRef.current} />}  exact={true} />\n        </IonRouterOutlet>\n      </IonReactRouter>\n    </IonApp>\n  )\n};\n\n...\n\nconst Home: React.FC = () => {\n  const [showModal, setShowModal] = useState(false);\n  \n  return (\n    <IonPage>\n      <IonContent>\n        <IonModal\n          isOpen={showModal}\n          initialBreakpoint={0.5}\n          breakpoints={[0, 0.5, 1]}\n          onDidDismiss={() => setShowModal(false)}>\n          <p>This is modal content</p>\n        </IonModal>\n      </IonContent>\n    </IonPage>\n  );\n};\n\n```",
    "stencil": "### Inline Modal\n\n```tsx\nimport { Component, Element, h } from '@stencil/core';\nimport { actionSheetController } from '@ionic/core';\n\n@Component({\n  tag: 'modal-example',\n  styleUrl: 'modal-example.css'\n})\nexport class ModalExample {\n  @Element() el: any;\n  \n  componentDidLoad() {\n    this.routerOutlet = this.el.closest('ion-router-outlet');\n  }\n  \n  async canDismiss() {\n    const actionSheet = await actionSheetController.create({\n      header: 'Are you sure you want to discard your changes?',\n      buttons: [\n        {\n          text: 'Discard Changes',\n          role: 'destructive'\n        },\n        {\n          text: 'Keep Editing',\n          role: 'cancel'\n        }\n      ]\n    });\n    \n    await actionSheet.present();\n    \n    const { role } = await actionSheet.onDidDismiss();\n    \n    if (role === 'destructive') {\n      return true;\n    }\n    \n    return false;\n  }\n  \n  render() {\n    return (\n      <div>\n        {/* Default */}\n        <ion-modal isOpen={true}>\n          <ion-content>Modal Content</ion-content>\n        </ion-modal>\n        \n        {/* Use a trigger */}\n        <ion-button id=\"trigger-button\">Click to open modal</ion-button>\n        <ion-modal trigger=\"trigger-button\">\n          <ion-content>Modal Content</ion-content>\n        </ion-modal>\n        \n        {/* Sheet Modal */}\n        <ion-modal\n          isOpen={true}\n          breakpoints={[0.1, 0.5, 1]}\n          initialBreakpoint={0.5}\n        >\n          <ion-content>Modal Content</ion-content>\n        </ion-modal>\n        \n        {/* Card Modal */}\n        <ion-modal\n          isOpen={true}\n          swipeToClose={true}\n          presentingElement={this.routerOutlet}\n        >\n          <ion-content>Modal Content</ion-content>\n        </ion-modal>\n        \n        {/* Passing Props */}\n        <ion-modal isOpen={true}>\n          <app-stencil-component title=\"Ionic\"></app-stencil-component>\n        </ion-modal>\n        \n        {/* Require Action Sheet confirmation before dismissing */}\n        <ion-modal isOpen={true} canDismiss={() => this.canDismiss()}>\n          <ion-content>Modal Content</ion-content>\n        </ion-modal>\n      </div>\n    )\n  }\n}\n```\n\n### Modal Controller \n\n```tsx\nimport { Component, h } from '@stencil/core';\n\nimport { modalController } from '@ionic/core';\n\n@Component({\n  tag: 'modal-example',\n  styleUrl: 'modal-example.css'\n})\nexport class ModalExample {\n  async presentModal() {\n    const modal = await modalController.create({\n      component: 'page-modal',\n      cssClass: 'my-custom-class'\n    });\n    await modal.present();\n  }\n}\n```\n\n```tsx\nimport { Component, h } from '@stencil/core';\n\n@Component({\n  tag: 'page-modal',\n  styleUrl: 'page-modal.css',\n})\nexport class PageModal {\n  render() {\n    return [\n      <ion-list>\n        <ion-item>\n          <ion-label>Documentation</ion-label>\n        </ion-item>\n        <ion-item>\n          <ion-label>Feedback</ion-label>\n        </ion-item>\n        <ion-item>\n          <ion-label>Settings</ion-label>\n        </ion-item>\n      </ion-list>\n    ];\n  }\n}\n```\n\n> If you need a wrapper element inside of your modal component, we recommend using a `<div class=\"ion-page\">` so that the component dimensions are still computed properly.\n\n### Passing Data\n\nDuring creation of a modal, data can be passed in through the `componentProps`.\nThe previous example can be written to include data:\n\n```tsx\nasync presentModal() {\n  const modal = await modalController.create({\n    component: 'page-modal',\n    cssClass: 'my-custom-class',\n    componentProps: {\n      'firstName': 'Douglas',\n      'lastName': 'Adams',\n      'middleInitial': 'N'\n    }\n  });\n  await modal.present();\n}\n```\n\nTo get the data passed into the `componentProps`, set each one as a `@Prop`:\n\n```tsx\nimport { Component, Prop, h } from '@stencil/core';\n\n@Component({\n  tag: 'page-modal',\n  styleUrl: 'page-modal.css',\n})\nexport class PageModal {\n  // Data passed in by componentProps\n  @Prop() firstName: string;\n  @Prop() lastName: string;\n  @Prop() middleInitial: string;\n}\n```\n\n### Dismissing a Modal\n\nA modal can be dismissed by calling the dismiss method on the modal controller and optionally passing any data from the modal.\n\n```tsx\nexport class ModalPage {\n  ...\n\n  dismiss(data?: any) {\n    // dismiss the closest modal and optionally pass back data\n    (this.el.closest('ion-modal') as any).dismiss({\n      'dismissed': true\n    });\n  }\n}\n```\n\nAfter being dismissed, the data can be read in through the `onWillDismiss` or `onDidDismiss` attached to the modal after creation:\n\n```tsx\nconst { data } = await modal.onWillDismiss();\nconsole.log(data);\n```\n\n### Card Modals\n\nModals in iOS mode have the ability to be presented in a card-style and swiped to close. The card-style presentation and swipe to close gesture are not mutually exclusive, meaning you can pick and choose which features you want to use. For example, you can have a card-style modal that cannot be swiped or a full sized modal that can be swiped.\n\n> Card style modals when running on iPhone-sized devices do not have backdrops. As a result, the `--backdrop-opacity` variable will not have any effect.\n\n```tsx\nimport { Component, Element, h } from '@stencil/core';\n\nimport { modalController } from '@ionic/core';\n\n@Component({\n  tag: 'modal-example',\n  styleUrl: 'modal-example.css'\n})\nexport class ModalExample {\n  @Element() el: any;\n\n  async presentModal() {\n    const modal = await modalController.create({\n      component: 'page-modal',\n      cssClass: 'my-custom-class',\n      swipeToClose: true,\n      presentingElement: this.el.closest('ion-router-outlet'),\n    });\n    await modal.present();\n  }\n\n}\n```\n\nIn most scenarios, using the `ion-router-outlet` element as the `presentingElement` is fine. In cases where you are presenting a card-style modal from within another modal, you should pass in the top-most `ion-modal` element as the `presentingElement`.\n\n```tsx\nasync presentModal() {\n  const modal = await modalController.create({\n    component: 'page-modal',\n    cssClass: 'my-custom-class',\n    swipeToClose: true,\n    presentingElement: await modalController.getTop() // Get the top-most ion-modal\n  });\n  await modal.present();\n}\n```\n\n\n### Sheet Modals\n\n**Controller**\n```tsx\nimport { Component, Element, h } from '@stencil/core';\n\nimport { modalController } from '@ionic/core';\n\n@Component({\n  tag: 'modal-example',\n  styleUrl: 'modal-example.css'\n})\nexport class ModalExample {\n  @Element() el: any;\n\n  async presentModal() {\n    const modal = await modalController.create({\n      component: 'page-modal',\n      initialBreakpoint: 0.5,\n      breakpoints: [0, 0.5, 1]\n      \n    });\n    await modal.present();\n  }\n}\n```\n\n**Inline**\n```tsx\nimport { Component, State, h } from '@stencil/core';\n\n@Component({\n  tag: 'modal-example',\n  styleUrl: 'modal-example.css'\n})\nexport class ModalExample {\n  @State() isModalOpen: boolean = false;\n\n  render() {\n    return [\n      <ion-modal\n        isOpen={isModalOpen} \n        initialBreakpoint={0.5} \n        breakpoints={[0, 0.5, 1]}\n      >\n        <page-modal></page-modal>\n      <ion-modal>\n    ]\n  }\n}\n```",
    "vue": "### Inline Modal\n\n```html\n<!-- Default -->\n<ion-modal :is-open=\"true\">\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Use a trigger -->\n<ion-button id=\"trigger-button\">Click to open modal</ion-button>\n<ion-modal trigger=\"trigger-button\">\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Sheet Modal -->\n<ion-modal \n  :is-open=\"true\"\n  :breakpoints=\"[0.1, 0.5, 1]\"\n  :initialBreakpoint=\"0.5\"\n>\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Card Modal -->\n<ion-modal\n  :is-open=\"true\"\n  :swipe-to-close=\"true\"\n  :presenting-element=\"$parent.$refs.ionRouterOutlet\"\n>\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<!-- Passing Props -->\n<ion-modal :is-open=\"true\">\n  <app-vue-component title=\"Ionic\"></app-vue-component>\n</ion-modal>\n\n<!-- Require Action Sheet confirmation before dismissing -->\n<ion-modal\n  :is-open=\"true\"\n  :can-dismiss=\"canDismiss\"\n>\n  <ion-content>Modal Content</ion-content>\n</ion-modal>\n\n<script>\n  import { IonModal, IonButton, IonContent } from '@ionic/vue';\n  import { defineComponent } from 'vue';\n  import AppVueComponent from './AppVueComponent.vue'\n  \n  export default defineComponent({\n    components: { IonModal, IonButton, IonContent, AppVueComponent },\n    setup() {\n      const canDismiss = async () => {\n        const actionSheet = await actionSheetController.create({\n          header: 'Are you sure you want to discard your changes?',\n          buttons: [\n            {\n              text: 'Discard Changes',\n              role: 'destructive'\n            },\n            {\n              text: 'Keep Editing',\n              role: 'cancel'\n            }\n          ]\n        });\n        \n        await actionSheet.present();\n        \n        const { role } = await actionSheet.onDidDismiss();\n        \n        if (role === 'destructive') {\n          return true;\n        }\n        \n        return false;\n      };\n      \n      return { canDismiss }\n    }\n  });\n</script>\n```\n\n### Modal Controller\n\n```html\n<template>\n  <ion-header>\n    <ion-toolbar>\n      <ion-title>{{ title }}</ion-title>\n    </ion-toolbar>\n  </ion-header>\n  <ion-content class=\"ion-padding\">\n    {{ content }}\n  </ion-content>\n</template>\n\n<script>\nimport { IonContent, IonHeader, IonTitle, IonToolbar } from '@ionic/vue';\nimport { defineComponent } from 'vue';\n\nexport default defineComponent({\n  name: 'Modal',\n  props: {\n    title: { type: String, default: 'Super Modal' },\n  },\n  data() {\n    return {\n      content: 'Content',\n    }\n  },\n  components: { IonContent, IonHeader, IonTitle, IonToolbar }\n});\n</script>\n```\n\n```html\n<template>\n  <ion-page>\n    <ion-content class=\"ion-padding\">\n      <ion-button @click=\"openModal\">Open Modal</ion-button>\n    </ion-content>\n  </ion-page>\n</template>\n\n<script>\nimport { IonButton, IonContent, IonPage, modalController } from '@ionic/vue';\nimport Modal from './modal.vue'\n\nexport default {\n  components: { IonButton, IonContent, IonPage },\n  methods: {\n    async openModal() {\n      const modal = await modalController\n        .create({\n          component: Modal,\n          cssClass: 'my-custom-class',\n          componentProps: {\n            title: 'New Title'\n          },\n        })\n      return modal.present();\n    },\n  },\n}\n</script>\n```\n\nDevelopers can also use this component directly in their template:\n\n```html\n<template>\n  <ion-button @click=\"setOpen(true)\">Show Modal</ion-button>\n  <ion-modal\n    :is-open=\"isOpenRef\"\n    css-class=\"my-custom-class\"\n    @didDismiss=\"setOpen(false)\"\n  >\n    <Modal :data=\"data\"></Modal>\n  </ion-modal>\n</template>\n\n<script>\nimport { IonModal, IonButton } from '@ionic/vue';\nimport { defineComponent, ref } from 'vue';\nimport Modal from './modal.vue'\n\nexport default defineComponent({\n  components: { IonModal, IonButton, Modal },\n  setup() {\n    const isOpenRef = ref(false);\n    const setOpen = (state: boolean) => isOpenRef.value = state;\n    const data = { content: 'New Content' };\n    return { isOpenRef, setOpen, data }\n  }\n});\n</script>\n```\n\n> If you need a wrapper element inside of your modal component, we recommend using an `<ion-page>` so that the component dimensions are still computed properly.\n\n#### Card Modals\n\nModals in iOS mode have the ability to be presented in a card-style and swiped to close. The card-style presentation and swipe to close gesture are not mutually exclusive, meaning you can pick and choose which features you want to use. For example, you can have a card-style modal that cannot be swiped or a full sized modal that can be swiped.\n\n> Card style modals when running on iPhone-sized devices do not have backdrops. As a result, the `--backdrop-opacity` variable will not have any effect.\n\n```html\n<template>\n  <ion-page>\n    <ion-content>\n      <ion-button @click=\"setOpen(true)\">Show Modal</ion-button>\n      <ion-modal\n        :is-open=\"isOpenRef\"\n        css-class=\"my-custom-class\"\n        :swipe-to-close=\"true\"\n        :presenting-element=\"$parent.$refs.ionRouterOutlet\"\n        @didDismiss=\"setOpen(false)\"\n      >\n        <Modal :data=\"data\"></Modal>\n      </ion-modal>\n    </ion-content>\n  </ion-page>\n</template>\n\n<script lang=\"ts\">\nimport { IonModal, IonButton, IonContent, IonPage } from '@ionic/vue';\nimport { defineComponent, ref } from 'vue';\nimport Modal from './modal.vue'\n\nexport default defineComponent({\n  components: { IonModal, IonButton, Modal, IonContent, IonPage },\n  setup() {\n    const isOpenRef = ref(false);\n    const setOpen = (state: boolean) => isOpenRef.value = state;\n    const data = { content: 'New Content' };\n    return { isOpenRef, setOpen, data }\n  }\n});\n</script>\n```\n\n#### Sheet Modals\n\n```html\n<template>\n  <ion-page>\n    <ion-content class=\"ion-padding\">\n      <ion-button @click=\"openModal()\">Open Modal</ion-button>\n    </ion-content>\n  </ion-page>\n</template>\n\n<script>\nimport { IonButton, IonContent, IonPage, modalController } from '@ionic/vue';\nimport Modal from './modal.vue'\n\nexport default {\n  components: { IonButton, IonContent, IonPage },\n  methods: {\n    async openModal() {\n      const modal = await modalController\n        .create({\n          component: Modal,\n          initialBreakpoint: 0.5,\n          breakpoints: [0, 0.5, 1]\n        })\n      return modal.present();\n    },\n  },\n}\n</script>\n```"
  },
  "props": [
    {
      "name": "animated",
      "type": "boolean",
      "mutable": false,
      "attr": "animated",
      "reflectToAttr": false,
      "docs": "If `true`, the modal will animate.",
      "docsTags": [],
      "default": "true",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "backdropBreakpoint",
      "type": "number",
      "mutable": false,
      "attr": "backdrop-breakpoint",
      "reflectToAttr": false,
      "docs": "A decimal value between 0 and 1 that indicates the\npoint after which the backdrop will begin to fade in\nwhen using a sheet modal. Prior to this point, the\nbackdrop will be hidden and the content underneath\nthe sheet can be interacted with. This value is exclusive\nmeaning the backdrop will become active after the value\nspecified.",
      "docsTags": [],
      "default": "0",
      "values": [
        {
          "type": "number"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "backdropDismiss",
      "type": "boolean",
      "mutable": false,
      "attr": "backdrop-dismiss",
      "reflectToAttr": false,
      "docs": "If `true`, the modal will be dismissed when the backdrop is clicked.",
      "docsTags": [],
      "default": "true",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "breakpoints",
      "type": "number[] | undefined",
      "mutable": false,
      "reflectToAttr": false,
      "docs": "The breakpoints to use when creating a sheet modal. Each value in the\narray must be a decimal between 0 and 1 where 0 indicates the modal is fully\nclosed and 1 indicates the modal is fully open. Values are relative\nto the height of the modal, not the height of the screen. One of the values in this\narray must be the value of the `initialBreakpoint` property.\nFor example: [0, .25, .5, 1]",
      "docsTags": [],
      "values": [
        {
          "type": "number[]"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "canDismiss",
      "type": "(() => Promise<boolean>) | boolean | undefined",
      "mutable": false,
      "attr": "can-dismiss",
      "reflectToAttr": false,
      "docs": "Determines whether or not a modal can dismiss\nwhen calling the `dismiss` method.\n\nIf the value is `true` or the value's function returns `true`, the modal will close when trying to dismiss.\nIf the value is `false` or the value's function returns `false`, the modal will not close when trying to dismiss.",
      "docsTags": [],
      "values": [
        {
          "type": "(() => Promise<boolean>)"
        },
        {
          "type": "boolean"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "enterAnimation",
      "type": "((baseEl: any, opts?: any) => Animation) | undefined",
      "mutable": false,
      "reflectToAttr": false,
      "docs": "Animation to use when the modal is presented.",
      "docsTags": [],
      "values": [
        {
          "type": "((baseEl: any, opts?: any) => Animation)"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "handle",
      "type": "boolean | undefined",
      "mutable": false,
      "attr": "handle",
      "reflectToAttr": false,
      "docs": "The horizontal line that displays at the top of a sheet modal. It is `true` by default when\nsetting the `breakpoints` and `initialBreakpoint` properties.",
      "docsTags": [],
      "values": [
        {
          "type": "boolean"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "htmlAttributes",
      "type": "undefined | { [key: string]: any; }",
      "mutable": false,
      "reflectToAttr": false,
      "docs": "Additional attributes to pass to the modal.",
      "docsTags": [],
      "values": [
        {
          "type": "undefined"
        },
        {
          "type": "{ [key: string]: any; }"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "initialBreakpoint",
      "type": "number | undefined",
      "mutable": false,
      "attr": "initial-breakpoint",
      "reflectToAttr": false,
      "docs": "A decimal value between 0 and 1 that indicates the\ninitial point the modal will open at when creating a\nsheet modal. This value must also be listed in the\n`breakpoints` array.",
      "docsTags": [],
      "values": [
        {
          "type": "number"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "isOpen",
      "type": "boolean",
      "mutable": false,
      "attr": "is-open",
      "reflectToAttr": false,
      "docs": "If `true`, the modal will open. If `false`, the modal will close.\nUse this if you need finer grained control over presentation, otherwise\njust use the modalController or the `trigger` property.\nNote: `isOpen` will not automatically be set back to `false` when\nthe modal dismisses. You will need to do that in your code.",
      "docsTags": [],
      "default": "false",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "keyboardClose",
      "type": "boolean",
      "mutable": false,
      "attr": "keyboard-close",
      "reflectToAttr": false,
      "docs": "If `true`, the keyboard will be automatically dismissed when the overlay is presented.",
      "docsTags": [],
      "default": "true",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "leaveAnimation",
      "type": "((baseEl: any, opts?: any) => Animation) | undefined",
      "mutable": false,
      "reflectToAttr": false,
      "docs": "Animation to use when the modal is dismissed.",
      "docsTags": [],
      "values": [
        {
          "type": "((baseEl: any, opts?: any) => Animation)"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "mode",
      "type": "\"ios\" | \"md\"",
      "mutable": false,
      "attr": "mode",
      "reflectToAttr": false,
      "docs": "The mode determines which platform styles to use.",
      "docsTags": [],
      "values": [
        {
          "value": "ios",
          "type": "string"
        },
        {
          "value": "md",
          "type": "string"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "presentingElement",
      "type": "HTMLElement | undefined",
      "mutable": false,
      "reflectToAttr": false,
      "docs": "The element that presented the modal. This is used for card presentation effects\nand for stacking multiple modals on top of each other. Only applies in iOS mode.",
      "docsTags": [],
      "values": [
        {
          "type": "HTMLElement"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": true,
      "required": false
    },
    {
      "name": "showBackdrop",
      "type": "boolean",
      "mutable": false,
      "attr": "show-backdrop",
      "reflectToAttr": false,
      "docs": "If `true`, a backdrop will be displayed behind the modal.",
      "docsTags": [],
      "default": "true",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "swipeToClose",
      "type": "boolean",
      "mutable": false,
      "attr": "swipe-to-close",
      "reflectToAttr": false,
      "docs": "If `true`, the modal can be swiped to dismiss. Only applies in iOS mode.",
      "docsTags": [
        {
          "name": "deprecated",
          "text": "- To prevent modals from dismissing, use canDismiss instead."
        }
      ],
      "default": "false",
      "deprecation": "- To prevent modals from dismissing, use canDismiss instead.",
      "values": [
        {
          "type": "boolean"
        }
      ],
      "optional": false,
      "required": false
    },
    {
      "name": "trigger",
      "type": "string | undefined",
      "mutable": false,
      "attr": "trigger",
      "reflectToAttr": false,
      "docs": "An ID corresponding to the trigger element that\ncauses the modal to open when clicked.",
      "docsTags": [],
      "values": [
        {
          "type": "string"
        },
        {
          "type": "undefined"
        }
      ],
      "optional": false,
      "required": false
    }
  ],
  "methods": [
    {
      "name": "dismiss",
      "returns": {
        "type": "Promise<boolean>",
        "docs": ""
      },
      "signature": "dismiss(data?: any, role?: string | undefined) => Promise<boolean>",
      "parameters": [],
      "docs": "Dismiss the modal overlay after it has been presented.",
      "docsTags": [
        {
          "name": "param",
          "text": "data Any data to emit in the dismiss events."
        },
        {
          "name": "param",
          "text": "role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'."
        }
      ]
    },
    {
      "name": "getCurrentBreakpoint",
      "returns": {
        "type": "Promise<number | undefined>",
        "docs": ""
      },
      "signature": "getCurrentBreakpoint() => Promise<number | undefined>",
      "parameters": [],
      "docs": "Returns the current breakpoint of a sheet style modal",
      "docsTags": []
    },
    {
      "name": "onDidDismiss",
      "returns": {
        "type": "Promise<OverlayEventDetail<T>>",
        "docs": ""
      },
      "signature": "onDidDismiss<T = any>() => Promise<OverlayEventDetail<T>>",
      "parameters": [],
      "docs": "Returns a promise that resolves when the modal did dismiss.",
      "docsTags": []
    },
    {
      "name": "onWillDismiss",
      "returns": {
        "type": "Promise<OverlayEventDetail<T>>",
        "docs": ""
      },
      "signature": "onWillDismiss<T = any>() => Promise<OverlayEventDetail<T>>",
      "parameters": [],
      "docs": "Returns a promise that resolves when the modal will dismiss.",
      "docsTags": []
    },
    {
      "name": "present",
      "returns": {
        "type": "Promise<void>",
        "docs": ""
      },
      "signature": "present() => Promise<void>",
      "parameters": [],
      "docs": "Present the modal overlay after it has been created.",
      "docsTags": []
    },
    {
      "name": "setCurrentBreakpoint",
      "returns": {
        "type": "Promise<void>",
        "docs": ""
      },
      "signature": "setCurrentBreakpoint(breakpoint: number) => Promise<void>",
      "parameters": [],
      "docs": "Move a sheet style modal to a specific breakpoint. The breakpoint value must\nbe a value defined in your `breakpoints` array.",
      "docsTags": []
    }
  ],
  "events": [
    {
      "event": "didDismiss",
      "detail": "OverlayEventDetail<any>",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted after the modal has dismissed.\nShorthand for ionModalDidDismiss.",
      "docsTags": []
    },
    {
      "event": "didPresent",
      "detail": "void",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted after the modal has presented.\nShorthand for ionModalWillDismiss.",
      "docsTags": []
    },
    {
      "event": "ionBreakpointDidChange",
      "detail": "ModalBreakpointChangeEventDetail",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted after the modal breakpoint has changed.",
      "docsTags": []
    },
    {
      "event": "ionModalDidDismiss",
      "detail": "OverlayEventDetail<any>",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted after the modal has dismissed.",
      "docsTags": []
    },
    {
      "event": "ionModalDidPresent",
      "detail": "void",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted after the modal has presented.",
      "docsTags": []
    },
    {
      "event": "ionModalWillDismiss",
      "detail": "OverlayEventDetail<any>",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted before the modal has dismissed.",
      "docsTags": []
    },
    {
      "event": "ionModalWillPresent",
      "detail": "void",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted before the modal has presented.",
      "docsTags": []
    },
    {
      "event": "willDismiss",
      "detail": "OverlayEventDetail<any>",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted before the modal has dismissed.\nShorthand for ionModalWillDismiss.",
      "docsTags": []
    },
    {
      "event": "willPresent",
      "detail": "void",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": "Emitted before the modal has presented.\nShorthand for ionModalWillPresent.",
      "docsTags": []
    }
  ],
  "listeners": [],
  "styles": [
    {
      "name": "--backdrop-opacity",
      "annotation": "prop",
      "docs": "Opacity of the backdrop"
    },
    {
      "name": "--background",
      "annotation": "prop",
      "docs": "Background of the modal content"
    },
    {
      "name": "--border-color",
      "annotation": "prop",
      "docs": "Border color of the modal content"
    },
    {
      "name": "--border-radius",
      "annotation": "prop",
      "docs": "Border radius of the modal content"
    },
    {
      "name": "--border-style",
      "annotation": "prop",
      "docs": "Border style of the modal content"
    },
    {
      "name": "--border-width",
      "annotation": "prop",
      "docs": "Border width of the modal content"
    },
    {
      "name": "--height",
      "annotation": "prop",
      "docs": "Height of the modal"
    },
    {
      "name": "--max-height",
      "annotation": "prop",
      "docs": "Maximum height of the modal"
    },
    {
      "name": "--max-width",
      "annotation": "prop",
      "docs": "Maximum width of the modal"
    },
    {
      "name": "--min-height",
      "annotation": "prop",
      "docs": "Minimum height of the modal"
    },
    {
      "name": "--min-width",
      "annotation": "prop",
      "docs": "Minimum width of the modal"
    },
    {
      "name": "--width",
      "annotation": "prop",
      "docs": "Width of the modal"
    }
  ],
  "slots": [
    {
      "name": "",
      "docs": "Content is placed inside of the `.modal-content` element."
    }
  ],
  "parts": [
    {
      "name": "backdrop",
      "docs": "The `ion-backdrop` element."
    },
    {
      "name": "content",
      "docs": "The wrapper element for the default slot."
    },
    {
      "name": "handle",
      "docs": "The handle that is displayed at the top of the sheet modal when `handle=\"true\"`."
    }
  ],
  "dependents": [],
  "dependencies": [
    "ion-backdrop"
  ],
  "dependencyGraph": {
    "ion-modal": [
      "ion-backdrop"
    ]
  }
}